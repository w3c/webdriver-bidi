<pre class=metadata>
Title: WebDriver BiDi
Shortname: webdriver-bidi
Level: 1
Status: ED
Group: browser-testing-tools
URL: https://w3c.github.io/webdriver-bidi/
Repository: w3c/webdriver-bidi
No Editor: true
Abstract: This document defines the BiDirectional WebDriver Protocol, a mechanism for remote control of user agents.
Boilerplate: conformance no
Complain About: accidental-2119 yes, missing-example-ids yes
Default Ref Status: current
Indent: 2
</pre>

<pre class=anchors>
spec: RFC6455; urlPrefix: https://tools.ietf.org/html/rfc6455
  type: dfn
    text: WebSocket URI; url: section-3
    text: Establishes a WebSocket Connection; url: section-4.1
    text: Server-Side Requirements; url: section-4.2
    text: Reading the Client's Opening Handshake; url: section-4.2.1
    text: %x1 denotes a text frame; url: section-5.2
    text: Send a WebSocket Message; url: section-6.1
    text: A WebSocket Message Has Been Received; url: section-6.2
    text: The WebSocket Closing Handshake is Started; url: section-7.1.3
    text: The WebSocket Connection is Closed; url: section-7.1.4
    text: Fail the WebSocket Connection; url: section-7.1.7
    text: Status Codes; url: section-7.4
    text: Handling Errors in UTF-8-Encoded Data; url: section-8.1
spec: RFC8610; urlPrefix: https://tools.ietf.org/html/rfc8610
  type: dfn
    text: match a CDDL specification; url: appendix-C
spec: WEBDRIVER; urlPrefix: https://w3c.github.io/webdriver/
  type: dfn
    text: WebDriver new session algorithm; url: dfn-webdriver-new-session-algorithm
    text: active sessions; url: dfn-active-session
    text: additional WebDriver capability; url: dfn-additional-webdriver-capability
    text: additional capability deserialization algorithm; url: dfn-additional-capability-deserialization-algorithm
    text: capability name; url: dfn-capability-name
    text: create a session; url: dfn-create-a-session
    text: draw a bounding box from the framebuffer; url: dfn-draw-a-bounding-box-from-the-framebuffer
    text: encode a canvas as Base64; url: dfn-encoding-a-canvas-as-base64
    text: endpoint node; url: dfn-endpoint-node
    text: error code; url: dfn-error-code
    text: error; url: dfn-errors
    text: getting a property; url: dfn-get-a-property
    text: http session; url: dfn-http-session
    text: intermediary node; url: dfn-intermediary-node
    text: invalid argument; url: dfn-invalid-argument
    text: invalid session id; url: dfn-invalid-session-id
    text: local end; url: dfn-local-ends
    text: matched capability serialization algorithm; url: dfn-matched-capability-serialization-algorithm
    text: maximum active sessions; url: dfn-maximum-active-sessions
    text: no such alert; url: dfn-no-such-alert
    text: no such element; url: dfn-no-such-element
    text: no such frame; url: dfn-no-such-frame
    text: process capabilities; url: dfn-processing-capabilities
    text: readiness state; url: dfn-readiness-state
    text: remote end steps; url: dfn-remote-end-steps
    text: remote end; url: dfn-remote-ends
    text: session ID; url: dfn-session-id
    text: session not created; url: dfn-session-not-created
    text: session; url: dfn-sessions
    text: set a property; url: dfn-set-a-property
    text: success; url: dfn-success
    text: try; url: dfn-try
    text: trying; url: dfn-try
    text: unknown command; url: dfn-unknown-command
    text: unknown error; url: dfn-unknown-error
    text: unsupported operation; url: dfn-unsupported-operation
    text: web element reference; url: dfn-web-element-reference
    text: webdriver-active flag; url: dfn-webdriver-active-flag
    text: window handle; url: dfn-window-handle
spec: CONSOLE; urlPrefix: https://console.spec.whatwg.org
  type: dfn
    text: formatter; url: formatter
    text: formatting specifier; url: formatting-specifiers
    text: printer; url: printer
spec: ECMASCRIPT; urlPrefix: https://tc39.es/ecma262/
  type: dfn
    text: Array; url: sec-array-objects
    text: Await; url: await
    text: BigInt; url: sec-bigint-constructor
    text: boolean; url: sec-terms-and-definitions-boolean-value
    text: Call; url: sec-call
    text: Completion Record; url: sec-completion-record-specification-type
    text: Construct; url: sec-construct
    text: CreateArrayFromList; url: sec-createarrayfromlist
    text: CreateArrayIterator; url: sec-createarrayiterator
    text: CreateListFromArrayLike; url: sec-createlistfromarraylike
    text: CreateMapIterator; url: sec-createmapiterator
    text: CreateSetIterator; url: sec-createsetiterator
    text: Date; url: sec-date-constructor
    text: Date Time String Format; url: sec-date-time-string-format
    text: Date.toISOString; url: sec-date.prototype.toisostring
    text: EnumerableOwnPropertyNames; url: sec-enumerableownpropertynames
    text: Get; url: sec-get
    text: HasProperty; url: sec-hasproperty
    text: IsArray; url: sec-isarray
    text: IsCallable; url: sec-iscallable
    text: IsPromise; url: sec-ispromise
    text: IsRegExp; url: sec-isregexp
    text: LengthOfArrayLike; url: sec-lengthofarraylike
    text: Map; url: sec-map-objects
    text: Number; url: sec-number-constructor
    text: null; url: sec-null-value
    text: Object; url: sec-object-objects
    text: Object.fromEntries; url: sec-object.fromentries
    text: ScriptEvaluation; url: sec-runtime-semantics-scriptevaluation
    text: Set object; url: sec-set-objects
    text: String; url: sec-string-constructor
    text: StringToBigInt; url: sec-stringtobigint
    text: StringToNumber; url: sec-stringtonumber
    text: RegExp; url: sec-regexp-pattern-flags
    text: ToString; url: sec-tostring
    text: Type; url: sec-ecmascript-data-types-and-values
    text: abrupt completion; url: sec-completion-record-specification-type
    text: undefined; url: sec-undefined-value
    text: current realm record; url: current-realm
    text: internal slot; url: sec-object-internal-methods-and-internal-slots
    text: primitive ECMAScript value; url: sec-primitive-value
    text: realm; url: sec-code-realms
    text: running execution context; url: running-execution-context
    text: time value; url: sec-time-values-and-time-range
    text: throw completion; url: sec-completion-record-specification-type
spec: GEOMETRY; urlPrefix: https://drafts.fxtf.org/geometry/
  type: dfn
    text: rectangle; url: rectangle
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/
  type: dfn
    text: a browsing context is discarded; url: window-object.html#a-browsing-context-is-discarded
    text: alert; url: timers-and-user-prompts.html#dom-alert
    text: close; url: window-object.html#close-a-browsing-context
    text: create a classic script; url: webappapis.html#creating-a-classic-script
    text: create a new browsing context; url: browsers.html#creating-a-new-browsing-context
    text: confirm; url: timers-and-user-prompts.html#dom-confirm
    text: default classic script fetch options; url: webappapis.html#default-classic-script-fetch-options
    text: environment settings object's Realm; url: webappapis.html#environment-settings-object's-realm
    text: handled; url: webappapis.html#concept-error-handled
    text: history handling behavior; url: browsing-the-web.html#history-handling-behavior
    text: navigation id; url: browsing-the-web.html#navigation-id
    text: prompt; url: timers-and-user-prompts.html#dom-prompt
    text: prompt to unload; url: browsing-the-web.html#prompt-to-unload-a-document
    text: report an error; url: webappapis.html#report-the-error
    text: remove a browsing context; url: browsers.html#bcg-remove
    text: run the animation frame callbacks; url: imagebitmap-and-animations.html#run-the-animation-frame-callbacks
    text: session history; url: history.html#session-history
    text: set up a window environment settings object; url: window-object.html#set-up-a-window-environment-settings-object
    text: set up a worker environment settings object; url: workers.html#set-up-a-worker-environment-settings-object
    text: set up a worklet environment settings object; url: worklets.html#set-up-a-worklet-environment-settings-object
    text: window open steps; url: window-object.html#window-open-steps
    text: worker event loop; url: webappapis.html#worker-event-loop-2
    text: worklet global scopes; url: worklets.html#concept-document-worklet-global-scopes
</pre>

<pre class="link-defaults">
spec:infra; type:dfn; for:/; text:set
</pre>

<style>
var {
  color: #cd5c5c
}
</style>

# Introduction # {#intro}

<em>This section is non-normative.</em>

[[WEBDRIVER|WebDriver]] defines a protocol for introspection and
remote control of user agents. This specification extends WebDriver by
introducing bidirectional communication. In place of the strict
command/response format of WebDriver, this permits events to stream
from the user agent to the controlling software, better matching the
evented nature of the browser DOM.

# Infrastructure # {#infrastructure}

This specification depends on the Infra Standard. [[!INFRA]]

Network protocol messages are defined using CDDL. [[!RFC8610]]

This specification defines a <dfn>wait queue</dfn> which is a map.

Issue: Surely there's a better mechanism for doing this "wait for an event" thing.

<div algorithm>

When an algorithm |algorithm| running [=in parallel=] <dfn>awaits</dfn> a set of
events |events|, and |resume id|:

1. Pause the execution of |algorithm|.

1. Assert: [=wait queue=] does not contain |resume id|.

1. Set [=wait queue=][|resume id|] to (|events|, |algorithm|).

</div>

<div algorithm>
To <dfn>resume</dfn> given |name|, |id| and |parameters|:

1. If [=wait queue=] does not contain |id|, return.

1. Let (|events|, |algorithm|) be [=wait queue=][|id|]

1. For each |event| in |events|:

  1. If |event| equals |name|:

    1. Remove |id| from [=wait queue=].

    1. Resume running the steps in |algorithm| from the
       point at which they were paused, passing |name| and |parameters| as the
       result of the [=await=].

       Issue: Should we have something like microtasks to ensure this runs
       before any other tasks on the event loop?

</div>

# Protocol # {#protocol}

This section defines the basic concepts of the WebDriver BiDi
protocol. These terms are distinct from their representation at the
<a href=#transport>transport</a> layer.

The protocol is defined using a [[!RFC8610|CDDL]] definition. For the
convenience of implementors two separate CDDL definitions are defined; the
<dfn>remote end definition</dfn> which defines the format of messages produced
on the [=local end=] and consumed on the [=remote end=], and the <dfn>local end
definition</dfn> which defines the format of messages produced on the [=remote
end=] and consumed on the [=local end=]

## Definition ## {#protocol-definition}

Issue: Should this be an appendix?

This section gives the initial contents of the [=remote end definition=] and
[=local end definition=]. These are augmented by the definition fragments defined in
the remainder of the specification.

[=Remote end definition=]

<pre class="cddl remote-cddl">
Command = {
  id: js-uint,
  CommandData,
  Extensible,
}

CommandData = (
  BrowsingContextCommand //
  ScriptCommand //
  SessionCommand
)

EmptyParams = {
   Extensible
}
</pre>

[=Local end definition=]

<pre class="cddl local-cddl">
Message = (
  CommandResponse //
  ErrorResponse //
  Event
)

CommandResponse = {
  id: js-uint,
  result: ResultData,
  Extensible
}

ErrorResponse = {
  id: js-uint / null,
  error: ErrorCode,
  message: text,
  ?stacktrace: text,
  Extensible
}

ErrorCode = {
   "invalid argument" //
   "no such alert" //
   "no such frame" //
   "session not created" //
   "unknown command" //
   "unknown error" //
   "unsupported operation"
}

ResultData = (
  EmptyResult //
  SessionResult //
  BrowsingContextResult //
  ScriptResult
)

EmptyResult = {}

Event = {
  EventData,
  Extensible
}

EventData = (
  BrowsingContextEvent //
  ScriptEvent //
  LogEvent
)
</pre>

[=Remote end definition=] and [=Local end definition=]

<pre class="cddl remote-cddl local-cddl">
Extensible = (*text => any)

js-uint = 0..9007199254740991
</pre>

## Session ## {#session}

WebDriver BiDi extends the [=/session=] concept from [[WEBDRIVER|WebDriver]].

A [=/session=] has a <dfn>BiDi flag</dfn>, which is false unless otherwise
stated.

A <dfn>BiDi session</dfn> is a [=/session=] which has the [=BiDi flag=]
set to true.

<div algorithm>
The set of <dfn>active BiDi sessions</dfn> is given by:

1. Let |BiDi sessions| be a new set.

1. For each |session| in [=active sessions=]:

  1. If |session| is a [=BiDi session=] append |session| to |BiDi sessions|.

1. Return |BiDi sessions|

</div>

## Modules ## {#protocol-modules}

The WebDriver BiDi protocol is organized into modules.

Each <dfn export>module</dfn> represents a collection of related
[=commands=] and [=events=] pertaining to a certain aspect of the user
agent. For example, a module might contain functionality for inspecting and
manipulating the DOM, or for script execution.

Each module has a <dfn>module name</dfn> which is a string. The
[=command name=] and [=event name=] for commands and events defined in the
module start with the [=module name=] followed by a period "<code>.</code>".

Modules which contain [=commands=] define [=remote end definition=]
fragments. These provide choices in the <code>CommandData</code> group for the
module's [=commands=], and can also define additional definition properties. They
can also define [=local end definition=] fragments that provide additional choices
in the <code>ResultData</code> group for the results of commands in the module.

Modules which contain events define [=local end definition=] fragments that are
choices in the <code>Event</code> group for the module's [=events=].

An implementation may define <dfn>extension modules</dfn>. These must have a
[=module name=] that contains a single colon "<code>:</code>" character. The
part before the colon is the prefix; this is typically the same for all
extension modules specific to a given implementation and should be unique for a
given implementation. Such modules extend the [=local end definition=] and [=remote
end definition=] providing additional groups as choices for the defined
[=commands=] and [=events=].

## Commands ## {#commands}

A <dfn export>command</dfn> is an asynchronous operation, requested by
the [=local end=] and run on the [=remote end=], resulting in either a
result or an error being returned to the [=local end=]. Multiple
commands can run at the same time, and commands can potentially be
long-running. As a consequence, commands can finish out-of-order.

Each [=command=] is defined by:

- A <dfn export for=command>command type</dfn> which is defined by a [=remote
   end definition=] fragment containing a group. Each such group has two fields:
    - <code>method</code> which is a string literal of the form <code>[module
      name].[method name]</code>. This is the <dfn export for=command>command
      name</dfn>.
    - <code>params</code> which defines a mapping containing data that to be passed into
      the command. The populated value of this map is the
      <dfn export for=command>command parameters</dfn>.
- A <dfn export for=command>result type</dfn>, which is defined by a [=local
  end definition=] fragment.
- A set of [=remote end steps=] which define the actions to take for a command
  given a [=BiDi session=] and [=command parameters=] and return an
  instance of the command [=return type=].

A command that can run without an active session is a <dfn>static
command</dfn>. Commands are not static commands unless stated in their
definition.

When commands are sent from the [=local end=] they have a command id. This is an
identifier used by the [=local end=] to identify the response from a particular
command. From the point of view of the [=remote end=] this identifier is opaque
and cannot be used internally to identify the command.

Note: This is because the command id is entirely controlled by the [=local end=]
and isn't necessarily unique over the course of a session. For example a [=local
end=] which ignores all responses could use the same command id for each command.

The <dfn export for=command>set of all command names</dfn> is a set containing
all the defined [=command names=], including any belonging to [=extension
modules=].

## Events ## {#events}

An <dfn export>event</dfn> is a notification, sent by the [=remote
end=] to the [=local end=], signaling that something of interest has
occurred on the [=remote end=].

 - An <dfn export for=event>event type</dfn> is defined by a [=local
   end definition=] fragment containing a group. Each such group has two fields:
    - <code>method</code> which is a string literal of the form <code>[module
      name].[event name]</code>. This is the <dfn export for=event>event
      name</dfn>.

    - <code>params</code> which defines a mapping containing event data. The
      populated value of this map is the <dfn export for=command>event
      parameters</code>.
 - A <dfn export>remote end event trigger</dfn> which defines when the event is
   triggered and steps to construct the [=event type=] data.
 - Optionally, a set of <dfn>remote end subscribe steps</dfn>, which define
   steps to take when a local end subscribes to an event. Where defined these
   steps have an associated <dfn>subscribe priority</dfn> which is an integer
   controlling the order in which the steps are run when multiple events are
   enabled at once, with lower integers indicating steps that run earlier.

A [=BiDi session=] has a <dfn export for=event>global event set</dfn>
which is a set containing the event names for events that are enabled for all
browsing contexts. This initially contains the [=event name=] for events that
are <dfn export for=event>in the default event set</dfn>.

A [=BiDi session=] has a <dfn export for=event>browsing context event
map</dfn>, which is a map with [=/top-level browsing context=] keys and values
that are a set of [=event name=]s for events that are enabled in the given
browsing context.

<div algorithm>

To obtain a list of <dfn>event enabled browsing contexts</dfn> given
|session| and |event name|:

1. Let |contexts| be an empty set.

1. For each |context| → |events| of |session|'s [=browsing context event map=]:

  1. If |events| contains |event name|, append |context| to |contexts|

1. Return |contexts|.

</div>

<div algorithm>

The <dfn>set of sessions for which an event is enabled</dfn> given |event name| and
|browsing contexts| is:

1. Let |sessions| be a new set.

1. For each |session| in [=active BiDI sessions=]:

  1. If [=event is enabled=] with |session|, |event name| and |browsing
     contexts|, append |session| to |sessions|.

1. Return |sessions|

</div>

<div algorithm>

To determine if an <dfn>event is enabled</dfn> given |session|,
|event name| and |browsing contexts|:

Note: |browsing contexts| is a set because a [=shared worker=] can be associated
      with multiple contexts.

1. Let |top-level browsing contexts| be an empty set.

1. For each |browsing context| of |browsing contexts|, append |browsing
   context|'s [=top-level browsing context=] to |top-level browsing contexts|.

1. Let |event map| be the [=browsing context event map=] for |session|.

1. For each |browsing context| of |top-level browsing contexts|:

  1. If |event map| [=contains=] |browsing context|, let |browsing context
     events| be |event map|[|browsing context|].  Otherwise let |browsing
     context events| be null.

  1. If |browsing context events| is not null, and |browsing context events|
     [=contains=] |event name|, return true.

1. If the [=global event set=] for |session| [=contains=] |event name| return
   true.

1. Return false.

</div>

<div algorithm>
To <dfn>obtain a set of event names</dfn> given an |name|:

1. Let |events| be an empty set.

1. If |name| contains a U+002E (period):

  1. If |name| is the [=event name=] for an event, append |name| to |events|
     and return [=success=] with data |events|.

  1. Return an [=error=] with [=error code=] [=invalid argument=]

1. Otherwise |name| is interpreted as representing all the events in a
   module. If |name| is not a [=module name=] return an [=error=] with
   [=error code=] [=invalid argument=].

1. Append the [=event name=] for each [=event=] in the module with name |name| to
   |events|.

1. Return [=success=] with data |events|.

</div>

# Transport # {#transport}

Message transport is provided using the WebSocket protocol.
[[!RFC6455]]

Note: In the terms of the WebSocket protocol, the [=local end=] is the
client and the [=remote end=] is the server / remote host.

Note: The encoding of [=commands=] and [=events=] as messages is
similar to JSON-RPC, but this specification does not normatively
reference it. [[JSON-RPC]] The normative requirements on [=remote
ends=] are instead given as a precise processing model, while no
normative requirements are given for [=local ends=].

A <dfn>WebSocket listener</dfn> is a network endpoint that is able
to accept incoming [[!RFC6455|WebSocket]] connections.

A [=WebSocket listener=] has a <dfn for=listener>host</dfn>, a <dfn
for=listener>port</dfn>, a <dfn for=listener>secure flag</dfn>, and a
<dfn>list of WebSocket resources</dfn>.

When a [=WebSocket listener=] |listener| is created, a [=remote end=]
must start to listen for WebSocket connections on the host and port
given by |listener|'s [=listener/host=] and [=listener/port=]. If
|listener|'s [=listener/secure flag=] is set, then connections
established from |listener| must be TLS encrypted.

A [=remote end=] has a [=set=] of [=WebSocket listeners=] <dfn>active
listeners</dfn>, which is initially empty.

A [=remote end=] has a [=set=] of <dfn>WebSocket connections not associated with a
session</dfn>, which is initially empty.

A <dfn>WebSocket connection</dfn> is a network connection that follows the
requirements of the [[!RFC6455|WebSocket protocol]]

A [=BiDi session=] has a set of <dfn>session WebSocket
connections</dfn> whose elements are [=WebSocket connections=]. This is
initially empty.

A [=BiDi session=] |session| is <dfn>associated with connection</dfn>
|connection| if |session|'s [=session WebSocket connections=] contains |connection|.

Note: Each [=WebSocket connection=] is associated with at most one [=BiDi
session=].

<div>

When a client [=establishes a WebSocket connection=] |connection| by
connecting to one of the set of [=active listeners=] |listener|, the
implementation must proceed according to the WebSocket [=server-side
requirements=], with the following steps run when deciding whether to
accept the incoming connection:

1. Let |resource name| be the resource name from [=reading the
   client's opening handshake=]. If |resource name| is not in
   |listener|'s [=list of WebSocket resources=], then stop
   running these steps and act as if the requested service is not
   available.

1. If |resource name| is the byte string "<code>/session</code>",
   and the implementation [=supports BiDi-only sessions=]:

    1. Run any other implementation-defined steps to decide if the
       connection should be accepted, and if it is not stop running these
       steps and act as if the requested service is not available.

    1. Add the connection to the set of [=WebSocket connections not associated
       with a session=].

    1. Return.

1. [=Get a session ID for a WebSocket resource=] with |resource name|
   and let |session id| be that value. If |session id| is null then
   stop running these steps and act as if the requested service is not
   available.

1. If there is a [=/session=] in the list of [=active sessions=] with
   |session id| as its [=session ID=] then let |session| be that
   session. Otherwise stop running these steps and act as if the
   requested service is not available.

1. Run any other implementation-defined steps to decide if the
   connection should be accepted, and if it is not stop running these
   steps and act as if the requested service is not available.

1. Otherwise append |connection| to |session|'s [=session WebSocket
   connections=], and proceed with the WebSocket [=server-side requirements=]
   when a server chooses to accept an incoming connection.

Issue: Do we support > 1 connection for a single session?

</div>

When [=a WebSocket message has been received=] for a [=WebSocket
connection=] |connection| with type |type| and data |data|, a [=remote
end=] must [=handle an incoming message=] given |connection|, |type|
and |data|.

When [=the WebSocket closing handshake is started=] or when [=the
WebSocket connection is closed=] for a [=WebSocket connection=]
|connection|, a [=remote end=] must [=handle a connection closing=]
given |connection|.

Note: Both conditions are needed because it is possible for a
WebSocket connection to be closed without a closing handshake.

<div algorithm>

To <dfn lt="construct a WebSocket resource name|constructing a
WebSocket resource name">construct a WebSocket resource name</dfn>
given a [=/session=] |session|:

1. If |session| is null, return "<code>/session</code>"

1. Return the result of concatenating the string "<code>/session/</code>"
   with |session|'s [=session ID=].

</div>

<div algorithm>

To <dfn lt="construct a WebSocket URL|constructing a WebSocket
URL">construct a WebSocket URL</dfn> given a [=WebSocket listener=]
|listener| and [=/session=] |session|:

1. Let |resource name| be the result of [=constructing a WebSocket
   resource name=] given |session|.

1. Return a [=WebSocket URI=] constructed with host set to
   |listener|'s [=listener/host=], port set to |listener|'s
   [=listener/port=], path set to |resource name|, following the wss-URI
   construct if |listener|'s [=listener/secure flag=] is set and the ws-URL
   construct otherwise.

</div>

<div algorithm>

To <dfn>get a session ID for a WebSocket resource</dfn>
given |resource name|:

1. If |resource name| doesn't begin with the byte string
   "<code>/session/</code>", return null.

1. Let |session id| be the bytes in |resource name| following the
   "<code>/session/</code>" prefix.

1. If |session id| is not the string representation of a
   [[!RFC4122|UUID]], return null.

1. Return |session id|.

</div>

<div algorithm>
To <dfn>start listening for a WebSocket connection</dfn> given a
[=/session=] |session|:

1. If there is an existing [=WebSocket listener=] in the set of
   [=active listeners=] which the [=remote end=] would like to reuse,
   let |listener| be that listener. Otherwise let |listener| be a new
   [=WebSocket listener=] with [=implementation-defined=]
   [=listener/host=], [=listener/port=], [=listener/secure flag=],
   and an empty [=list of WebSocket resources=].

1. Let |resource name| be the result of [=constructing a WebSocket
   resource name=] given |session|.

1. Append |resource name| to the [=list of WebSocket resources=] for
   |listener|.

1. [=set/Append=] |listener| to the [=remote end=]'s [=active
    listeners=].

1. Return |listener|.

</div>

Note: An [=intermediary node=] handling multiple sessions can use one
or many WebSocket listeners. [[!WEBDRIVER|WebDriver]] defines that
an [=endpoint node=] supports at most one session at a time, so it's
expected to only have a single listener.

Note: For an [=endpoint node=] the [=listener/host=] in the above steps will
typically be "<code>localhost</code>".

<div algorithm>
To <dfn>handle an incoming message</dfn> given a [=WebSocket connection=]
|connection|, type |type| and data |data|:

1. If |type| is not [=%x1 denotes a text frame|text=], [=respond with an
   error=] given |connection|, null, and [=invalid argument=], and finally
   return.

1. [=Assert=]: |data| is a [=scalar value string=], because the
    WebSocket [=handling errors in UTF-8-encoded data=] would already
    have [=fail the WebSocket connection|failed the WebSocket
    connection=] otherwise.

   Issue: Nothing seems to define what [=status codes|status code=]
   is used for UTF-8 errors.

1. If there is a [=BiDi Session=] [=associated with connection=] |connection|,
   let |session| be that session. Otherwise if |connection| is in the set of
   [=WebSocket connections not associated with a session=], let |session| be
   null. Otherwise, return.

1. Let |parsed| be the result of [=parse JSON into Infra values|parsing JSON
   into Infra values=] given |data|. If this throws an exception, then [=respond
   with an error=] given |connection|, null, and [=invalid argument=], and
   finally return.

1. Match |parsed| against the [=remote end definition=]. If this results in a
   match:

   1. Let |matched| be the map representing the matched data.

   1. Assert: |matched| [=contains=] "<code>id</code>", "<code>method</code>", and
      "<code>params</code>".

   1. Let |command id| be |matched|["<code>id</code>"].

   1. Let |method| be |matched|["<code>method</code>"]

    1. Let |command| be the command with [=command name=] |method|.

    1. If |session| is null and |command| is not a [=static command=], then
       [=respond with an error=] given |connection|, |command id|, and [=invalid
       session id=], and return.

    1. Run the following steps in parallel:

      1. Let |result| be the result of running the [=remote end steps=] for
         |command| given |session| and [=command parameters=]
         |matched|["<code>params</code>"]

     1. If |result| is an [=error=], then [=respond with an error=] given
        |connection|, |command id|, and |result|'s [=error code=], and finally
        return.

     1. Let |value| be |result|'s data.

     1. Assert: |value| matches the definition for the [=result type=]
        corresponding to the command with [=command name=] |method|.

     1. If |method| is "<code>session.new</code>", let |session| be the entry in
        the list of [=active sessions=] whose [=session ID=] is equal to the
        "<code>sessionId</code>" property of |value|, let |session|'s
        [=WebSocket connection=] be |connection|, and remove |connection| from
        the set of [=WebSocket connections not associated with a session=].

     1. Let |response| be a new map matching the <code>CommandResponse</code>
        production in the [=local end definition=] with the <code>id</code>
        field set to |command id| and the <code>value</code> field set to
        |value|.

     1. Let |serialized| be the result of [=serialize an infra value to JSON
        bytes=] given |response|.

     1. [=Send a WebSocket message=] comprised of |serialized| over
        |connection|.

1. Otherwise:

   1. Let |command id| be null.

   1. If |parsed| is a map and |parsed|["<code>id</code>"] exists and is an
      integer greater than or equal to zero, set |command id| to that integer.

   1. Let |error code| be [=invalid argument=].

   1. If |parsed| is a map and |parsed|["<code>method</code>"] exists and is a
      string, but |parsed|["<code>method</code>"] is not in the [=set of all
      command names=], set |error code| to [=unknown command=].

   1. [=Respond with an error=] given |connection|, |command id|, and
      |error code|.

</div>

<div algorithm>

To <dfn>get related browsing contexts</dfn> given an [=script/settings object=]
|settings|:

1. Let |related browsing contexts| be an empty set

1. If |settings|' [=relevant global object=] is a {{Window}}, append |settings|'
   [=relevant global object=]'s <a>associated <code>Document</code></a>'s
   [=Document/browsing context=] to |related browsing contexts|.

   Otherwise if the [=realm/global object=] specified by |settings| is a
   {{WorkerGlobalScope}}, for each |owner| in the [=realm/global object=]'s
   [=owner set=], if |owner| is a [=Document=], append |owner|'s
   [=Document/browsing context=] to |related browsing contexts|.

1. Return |related browsing contexts|.

</div>

<div algorithm> To <dfn export>emit an event</dfn> given |session|, and |body|:

1. [=Assert=]: |body| has [=map/size=] 2 and [=contains=] "<code>method</code>"
   and "<code>params</code>".

1. Let |connection| be |session|'s [=WebSocket connection=].

1. If |connection| is null, return.

1. Let |serialized| be the result of [=serialize an infra value to JSON
   bytes=] given |body|.

1. [=Send a WebSocket message=] comprised of |serialized| over |connection|.

</div>

<div algorithm>
To <dfn>respond with an error</dfn> given a [=WebSocket connection=]
|connection|, |command id|, and |error code|:

1. Let |error data| be a new map matching the <code>ErrorResponse</code>
   production in the [=local end definition=], with the <code>id</code> field
   set to |command id|, the <code>error</code> field set to |error code|, the
   <code>message</code> field set to an implementation-defined string
   containing a human-readable definition of the error that occurred and the
   <code>stacktrace</code> field optionally set to an implementation-defined
   string containing a stack trace report of the active stack frames at the
   time when the error occurred.

1. Let |response| be the result of [=serialize an infra value to JSON bytes=]
   given |error data|.

   Note: |command id| can be null, in which case the <code>id</code> field will
   also be set to null, not omitted from |response|.

1. [=Send a WebSocket message=] comprised of |response| over |connection|.

</div>


<div algorithm>

To <dfn>handle a connection closing</dfn> given a [=WebSocket connection=]
|connection|:

1. If there is a [=BiDi session=] [=associated with connection=] |connection|:

  1. Let |session| be the [=BiDi session=] [=associated with connection=]
     |connection|.

  1. Remove |connection| from |session|'s [=session WebSocket
     connections=].

1. Otherwise, if the set of [=WebSocket connections not associated with a session=]
   contains |connection|, remove |connection| from that set.

</div>

Note: This does not end any [=/session=].

Issue: Need to hook in to the session ending to allow the UA to close
the listener if it wants.

## Establishing a Connection ## {#establishing}

WebDriver clients opt in to a bidirectional connection by requesting a
capability with the name "<code>webSocketUrl</code>" and value
true.

This specification defines an
[=additional webdriver capability=] with the [=capability name=] "<code>webSocketUrl</code>".

<div algorithm="webSocketUrl capability deserialization algorithm">
The [=additional capability deserialization algorithm=] for the
"<code>webSocketUrl</code>" capability, with parameter |value| is:

1. If |value| is not a boolean, return [=error=] with [=error code|code=]
   [=invalid argument=].

1. Return [=success=] with data |value|.

</div>

<div algorithm="webSocketUrl capability serialization algorithm">
The [=matched capability serialization algorithm=] for the "<code>webSocketUrl</code>" capability,
with parameter |value| is:

1. If |value| is false, return [=success=] with data null.

1. Return [=success=] with data true.

</div>

<div algorithm="webSocketUrl new session algorithm">
The [=WebDriver new session algorithm=] defined by this specification,
with parameters |session|, |capabilities|, and |flags| is:

1. If |flags| contains "<code>bidi</code>", return.

1. Let |webSocketUrl| be the result of [=getting a property=] named
   "<code>webSocketUrl</code>" from |capabilities|.

1. If |webSocketUrl| is undefined or false, return.

1. [=Assert=]: |webSocketUrl| is true.

1. Let |listener| be the result of [=start listening for a WebSocket
   connection=] given |session|.

1. Set |webSocketUrl| to the result of [=constructing a WebSocket
   URL=] given |listener| and |session|.

1. [=Set a property=] on |capabilities| named
   "<code>webSocketUrl</code>" to |webSocketUrl|.

1. Set |session|'s [=BiDi flag=] to true.

1. Append "<code>bidi</code>" to flags.

</div>

<div algorithm="no HTTP new session">

Implementations should also allow clients to establish a [=BiDi Session=] which
is not a [=HTTP Session=]. In this case the URL to the WebSocket server is
communicated out-of-band. An implementation that allows this <dfn>supports
BiDi-only sessions</dfn>. At the time such an implementation is ready to accept
requests to start a WebDriver session, it must:

1. [=Start listening for a WebSocket connection=] given null.

</div>

# Sandboxed Script Execution # {#sandbox}

A common requirement for automation tools is to execute scripts which have
access to the DOM of a document, but don't have information about any changes to
the DOM APIs made by scripts running in the browsing context containing the
document.

A [=BiDi session=] has a <dfn>sandbox map</dfn> which is a weak map in which the
keys are [=window=] objects, and the values are maps between strings and
{{SandboxWindowProxy}} objects.

Note: The definition of sandboxes here is an attempt to codify the behaviour of
existing implementations. It exposes parts of the implementations that have
previously been considered internal by specifications, in particular the
distinction between the internal state of platform objects (which is typically
implemented as native objects in the main implementation language of the browser
engine) and the ECMAScript-visible state. Because existing sandbox
implementations happen at a low level in the engine, implementations converging
toward the specification in all details might be a slow process. In the
meantime, implementors are encouraged to provide detailed documentation on any
differences with the specification, and users of this feature are encouraged to
explicitly test that scripts running in sandboxes work in all implementations.

## Sandbox Realms ## {#sandbox-realm}

Each sandbox is a unique EMCAScript [=Realm=]. However the sandbox realm
provides access to platform objects in an existing {{Window}} realm via
{{SandboxProxy}} objects.

<div algorithm>
To <dfn>get or create a sandbox realm</dfn> given |name| and |browsing context|:

1. If |name| is an empty string, then return [=error=] with
   [=error code=] [=invalid argument=].

1. Let |window| be |browsing context|'s [=active window=].

1. If [=sandbox map=] does not contain |window|, set [=sandbox map=][|window|]
   to a new map.

1. Let |sandboxes| be [=sandbox map=][|window|].

1. If |sandboxes| does not contain |name|, set |sandboxes|[|name|] to [=create
   a sandbox realm=] with |browsing context|.

1. Return [=success=] with data |sandboxes|[|name|].

</div>

<div algorithm>
To <dfn>create a sandbox realm</dfn> with |window|:

Issue: Define creation of sandbox realm. This is going to return a
{{SandboxWindowProxy}} wrapping |window|.

</div>

<div algorithm>

To <dfn>get a sandbox name</dfn> given |target realm|:

1. Let |realms maps| be [=get the values=] of [=sandbox map=].

1. For each |realms map| in |realms maps|:

  1. For each |name| → |realm| in |realms map|:

    1. If |realm| is |target realm|, return |name|.

1. Return null.

</div>

## Sandbox Proxy Objects ## {#sandbox-proxy}

A <dfn interface>SandboxProxy</dfn> object is an exotic object that mediates sandboxed access to
objects from another realm. Sandbox proxy objects are designed to enforce the
following restrictions:

* Platform objects are accessible, but property access returns only
  Web IDL-defined properties and not ECMAScript-defined properties (either
  "expando" properties that are not present in the underlying interface, or
  ECMAScript-defined properties that shadow a property in the underlying
  interface).

* Setting a property either runs Web IDL-defined setter steps, or sets a property
  on the proxy object. This means that properties written outside the sandbox
  are not accessible, but interface members can be used as normal.

There is no {{SandboxProxy}} interface object.

Issue: Define in detail how {{SandboxProxy}} works

## SandboxWindowProxy ## {#sandbox-sandboxwindowproxy}

A <dfn interface>SandboxWindowProxy</dfn> is an exotic object that represents a
{{Window}} object wrapped by a {{SandboxProxy}} object. This provides sandboxed
access to that data in a {{Window}} global.

Issue: Define how this works.

# Common Data Types # {#data-types}

## Reference ## {#data-types-reference}

Each EMCAScript [=Realm=] has a corresponding <dfn>handle object map</dfn>. This is a
strong map from handle ids to their corresponding objects.

<pre class="cddl remote-cddl">
OwnershipModel = "root" / "none";
</pre>

<dfn>RemoteReference</dfn> represents a remote reference to an existing ECMAScript
object in [=handle object map=] in the given [=Realm=].

<pre class="cddl remote-cddl local-cddl">
Handle = text;

RemoteReference = {
   handle: Handle,
   Extensible
}
</pre>

Issue: handle "stale object reference" case.

<div algorithm>
To <dfn>deserialize remote reference</dfn> given |realm| and |remote reference|:

1. Let |handle id| be the value of the <code>handle</code> field of |remote reference|.

1. Let |handle map| be |realm|'s [=handle object map=]

1. If |handle map| does not contain |handle id|, then return [=error=] with
   [=error code=] [=invalid argument=].

1. Return |handle map|[|handle id|].

</div>

## Protocol Value ## {#data-types-protocolValue}

### Primitive Protocol Value ### {#data-types-protocolValue-primitiveProtocolValue}

<dfn>PrimitiveProtocolValue</dfn> represents values which can only be represented by value, never
by reference.

<pre class="cddl remote-cddl local-cddl">
PrimitiveProtocolValue = {
  UndefinedValue //
  NullValue //
  StringValue //
  NumberValue //
  BooleanValue //
  BigIntValue //
}

UndefinedValue = {
  type: "undefined",
}

NullValue = {
  type: "null",
}

StringValue = {
  type: "string",
  value: text,
}

SpecialNumber = "NaN" / "-0" / "Infinity" / "-Infinity";

NumberValue = {
  type: "number",
  value: number / SpecialNumber,
}

BooleanValue = {
  type: "boolean",
  value: bool,
}

BigIntValue = {
  type: "bigint",
  value: text,
}
</pre>

#### Serialization #### {#data-types-protocolValue-primitiveProtocolValue-serialization}

<div algorithm>

To <dfn>serialize primitive protocol value</dfn> given a |value|:

1. Let |remote value| be undefined.

1. In the following list of conditions and associated steps, run the first set
   of steps for which the associated condition is true, if any:

  <dl>
    <dt>[=Type=](|value|) is undefined
    <dd>Let |remote value| be a map matching the <code>UndefinedValue</code>
    production in the [=local end definition=].

    <dt>[=Type=](|value|) is Null
    <dd>Let |remote value| be a map matching the <code>NullValue</code>
    production in the [=local end definition=].

    <dt>[=Type=](|value|) is String
    <dd>Let |remote value| be a map matching the <code>StringValue</code>
    production in the [=local end definition=], with the <code>value</code>
    property set to |value|.

    Issue: This doesn't handle lone surrogates

    <dt>[=Type=](|value|) is Number
    <dd>
    1. Switch on the value of |value|:
      <dl>
        <dt>NaN
        <dd>Let |serialized| be <code>"NaN"</code>
        <dt>-0
        <dd>Let |serialized| be <code>"-0"</code>
        <dt>Infinity
        <dd>Let |serialized| be <code>"Infinity"</code>
        <dt>-Infinity
        <dd>Let |serialized| be <code>"-Infinity"</code>
        <dt>Otherwise:
        <dd>Let |serialized| be |value|
      </dl>

    1. Let |remote value| be a map matching the <code>NumberValue</code>
       production in the [=local end definition=], with the <code>value</code>
       property set to |serialized|.

    <dt>[=Type=](|value|) is Boolean
    <dd>Let |remote value| be a map matching the <code>BooleanValue</code>
        production in the [=local end definition=], with the <code>value</code>
        property set to |value|.

    <dt>[=Type=](|value|) is BigInt
    <dd>Let |remote value| be a map matching the <code>BigIntValue</code>
        production in the [=local end definition=], with the <code>value</code>
        property set to the result of running the [=ToString=] operation on
        |value|.

  </dl>

1. Return |remote value|

</div>

#### Deserialization #### {#data-types-protocolValue-primitiveProtocolValue-deserialization}

<div algorithm>

To <dfn>deserialize primitive protocol value</dfn> given a |primitive protocol value|:

1. Let |type| be the value of the <code>type</code> field of |primitive protocol value|.

1. Let |value| be undefined.

1. If |primitive protocol value| has field <code>value</code>:
   1. Let |value| be the value of the <code>value</code> field of |primitive protocol value|.

1. In the following list of conditions and associated steps, run the first set of steps for which
   the associated condition is true:

  <dl>

    <dt>|type| is the string "<code>undefined</code>"
    <dd>Return [=success=] with data [=undefined=].

    <dt>|type| is the string "<code>null</code>"
    <dd>Return [=success=] with data [=null=].

    <dt>|type| is the string "<code>string</code>"
    <dd>Return [=success=] with data |value|.

    <dt>|type| is the string "<code>number</code>"
    <dd>
      1. If [=Type=](|value|) is Number, return [=success=] with data |value|.

      1. Assert: [=Type=](|value|) is String.

      1. If |value| is the string "<code>NaN</code>", return [=success=] with
         data NaN.

      1. Let |number_result| be [=StringToNumber=](|value|).

      1. If |number_result| is NaN, return [=error=] with [=error code=] [=invalid argument=]

      1. Return [=success=] with data |number_result|.

    <dt>|type| is the string "<code>boolean</code>"
    <dd>Return [=success=] with data |value|.

    <dt>|type| is the string "<code>bigint</code>"
    <dd>
      1. Let |bigint_result| be [=StringToBigInt=](|value|).

      1. If |bigint_result| is undefined, return [=error=] with [=error code=] [=invalid argument=]

      1. Return [=success=] with data |bigint_result|.

  </dl>

1. Return [=error=] with [=error code=] [=invalid argument=]

</div>

### Local Value ### {#data-types-protocolValue-LocalValue}

<dfn export>LocalValue</dfn> represents both primitive and non-primitive values which can be deserialized
to ECMAScript without reference to existing objects.


<pre class="cddl remote-cddl local-cddl">
LocalValue = {
  PrimitiveProtocolValue //
  ArrayLocalValue //
  DateLocalValue //
  MapLocalValue //
  ObjectLocalValue //
  RegExpLocalValue //
  SetLocalValue //
}

ListLocalValue = [*LocalValue];

ArrayLocalValue = {
  type: "array",
  value: ListLocalValue,
}

DateLocalValue = {
  type: "date",
  value: text
}

MappingLocalValue = [*[(LocalValue / text), LocalValue]];

MapLocalValue = {
  type: "map",
  value: MappingLocalValue,
}

ObjectLocalValue = {
  type: "object",
  value: MappingLocalValue,
}

RegExpValue = {
  pattern: text,
  ?flags: text,
}

RegExpLocalValue = {
  type: "regexp",
  value: RegExpValue,
}

SetLocalValue = {
  type: "set",
  value: ListLocalValue,
}
</pre>

#### Deserialization #### {#data-types-protocolValue-LocalValue-deserialization}

<div algorithm>

To <dfn>deserialize key-value list</dfn> given |realm| and |serialized key-value list|:

1. Let |deserialized key-value list| be a new list.

1. For each |serialized key-value| in the |serialized key-value list|:

   1. If [=list/size=] of |serialized key-value| is not 2,
      return [=error=] with [=error code=] [=invalid argument=].

   1. Let |serialized key| be |serialized key-value|[0].

   1. If |serialized key| is a <code>string</code>,
      let |deserialized key| be |serialized key|.

   1. Otherwise let |deserialized key| be result of [=trying=] to [=deserialize local value=]
      given |realm| and |serialized key|.

   1. Let |serialized value| be |serialized key-value|[1].

   1. Let |deserialized value| be result of [=trying=] to [=deserialize local value=]
      given |realm| and |serialized value|.

   1. Append [=CreateArrayFromList=](«|deserialized key|, |deserialized value|») to
      |deserialized key-value list|.

1. Return [=success=] with data [=CreateArrayFromList=](|deserialized key-value list|).

</div>

<div algorithm>

Issue: TODO distinguish between `List` and `Array`.

To <dfn>deserialize value list</dfn> given |realm| and |serialized value list|:

1. Let |deserialized values| be a new list.

1. For each |serialized value| in the |serialized value list|:

   1. Let |deserialized value| be result of [=trying=] to [=deserialize local value=] with
      given |realm| and |serialized value|.

   1. Append |deserialized value| to |deserialized values|;

1. Return [=success=] with data |deserialized values|.

</div>

<div algorithm>

To <dfn>deserialize local value</dfn> given |realm| and |local protocol value|:

1. If |local protocol value| matches the [=RemoteReference=] production, return
   [=deserialize remote reference=] of given |realm| and |local protocol value|.

1. If |local protocol value| matches the [=PrimitiveProtocolValue=] production, return
   [=deserialize primitive protocol value=] with |local protocol value|.

1. Let |type| be the value of the <code>type</code> field of |local protocol value| or undefined if
   no such a field.

1. Let |value| be the value of the <code>value</code> field of |local protocol value| or undefined
   if no such a field.

1. In the following list of conditions and associated steps, run the first set of steps for which
   the associated condition is true:

  <dl>

    <dt>|type| is the string "<code>array</code>"
    <dd>
      1. Let |deserialized value list| be a result of [=trying=] to [=deserialize value list=]
         given |realm| and |value|.

      1. Return [=success=] with data [=CreateArrayFromList=](|deserialized value list|).

    <dt>|type| is the string "<code>date</code>"
    <dd>
      1. If |value| does not match [=Date Time String Format=], return [=error=] with
         [=error code=] [=invalid argument=].

      1. Let |date result| be [=Construct=]([=Date=], |value|).

      1. Assert: |date result| is not an [=abrupt completion=].

      1. Return [=success=] with data |date result|.

    <dt>|type| is the string "<code>map</code>"
    <dd>
      1. Let |deserialized key-value list| be a result of [=trying=] to
         [=deserialize key-value list=] given |realm| and |value|.

      1. Let |iterable| be [=CreateArrayFromList=](|deserialized key-value list|)

      1. Return [=success=] with data [=Map=](|iterable|).

    <dt>|type| is the string "<code>object</code>"
    <dd>
      1. Let |deserialized key-value list| be a result of [=trying=] to
         [=deserialize key-value list=] given |realm| and |value|.

      1. Let |iterable| be [=CreateArrayFromList=](|deserialized key-value list|)

      1. Return [=success=] with data [=Object.fromEntries=](|iterable|).

    <dt>|type| is the string "<code>regexp</code>"
    <dd>
      1. Let |pattern| be the value of the <code>pattern</code> field of |local protocol value|.

      1. Let |flags| be the value of the <code>flags</code> field of |local protocol value| or
         undefined if no such a field.

      1. Let |regex_result| be [=Regexp=](|pattern|, |flags|). If this throws exception, return [=error=]
         with [=error code=] [=invalid argument=].

      1. Return [=success=] with data |regex_result|.

    <dt>|type| is the string "<code>set</code>"
    <dd>
      1. Let |deserialized value list| be a result of [=trying=] to [=deserialize value list=]
         given |realm| and |value|.

      1. Let |iterable| be [=CreateArrayFromList=](|deserialized key-value list|)

      1. Return [=success=] with data [=Set object=](|iterable|).

    <dt>otherwise
    <dd>Return [=error=] with [=error code=] [=invalid argument=].
  </dl>

</div>

### Remote Value ### {#data-types-protocolValue-RemoteValue}

Values accessible from the ECMAScript runtime are represented by a mirror
object, specified as <code>RemoteValue</code>. The value's type is specified in
the <code>type</code> property. In the case of JSON-representable primitive
values, this contains the value in the <code>value</code> property; in the case
of non-JSON-representable primitives, the <code>value</code> property contains a
string representation of the value.
For non-primitive objects, the <code>handle</code> property, when present, contains a
unique string handle to the object. The handle is unique for each serialization. The
remote end will keep objects with a corresponding handle alive until such a time that
<code>script.disown</code> is called with that handle, or the realm itself is to be
discarded (e.g. due to navigation).
For some non-primitive types, the <code>value</code> property contains a
representation of the data in the ECMAScript object; for container types this can
contain further <code>RemoteValue</code> instances. The <code>value</code> property
can be null or omitted if there is a duplicate object i.e. the object has already
been serialized in the current <code>RemoteValue</code>, perhaps as part of a cycle,
or otherwise when the maximum serialization depth is reached.
In case of duplicated objects in the same <code>RemoteValue</code>, the value is
provided only for one of the remote values, while the unique-per-ECMAScript-object
<code>internalId</code> is provided for all the duplicated objects for a given
serialization.

[=Nodes=] are also represented by <code>RemoteValue</code> instances. These have
a partial serialization of the node in the value property.

Issue: reconsider mirror objects' lifecycle.

Note: mirror objects do not keep the original object alive in the runtime. If an
object is discarded in the runtime, subsequent attempts to access it via the
protocol will result in an error.

<div algorithm>
To get the <dfn>handle for an object</dfn> given |realm|, |ownership type| and
|object|:

1. If |ownership type| is equal "<code>none</code>", return <code>null</code>.

1. Let |handle id| be a new, unique, string handle for |object|.

1. Let |handle map| be |realm|'s [=handle object map=]

1. Set |handle map|[|handle id|] to |object|.

1. Return |handle id| as a result.

</div>

<div algorithm>
To <dfn>set internal ids if needed</dfn> given |serialization internal map|,
|remote value| and |object|:

1. If the |serialization internal map| does not contain |object|, set
   |serialization internal map|[|object|] to |remote value|.

1. Otherwise, run the following steps:

    1. Let |previously serialized remote value| be
       |serialization internal map|[|object|].

    1. If |previously serialized remote value| does not have a field
       <code>internalId</code>, run the following steps:

      1. Let |internal id| be a unique across the <code>internalId</code> fields of
         the values of |serialization internal map| integer.

       1. Set the <code>internalId</code> field of
          |previously serialized remote value| to |internal id|.

    1. Set the <code>internalId</code> field of |remote value| to a field
       <code>internalId</code> in |previously serialized remote value|.

</div>

[=remote end definition=] and [=local end definition=]

<pre class="cddl remote-cddl local-cddl">
RemoteValue = {
  PrimitiveProtocolValue //
  SymbolRemoteValue //
  ArrayRemoteValue //
  ObjectRemoteValue //
  FunctionRemoteValue //
  RegExpRemoteValue //
  DateRemoteValue //
  MapRemoteValue //
  SetRemoteValue //
  WeakMapRemoteValue //
  WeakSetRemoteValue //
  IteratorRemoteValue //
  GeneratorRemoteValue //
  ErrorRemoteValue //
  ProxyRemoteValue //
  PromiseRemoteValue //
  TypedArrayRemoteValue //
  ArrayBufferRemoteValue //
  NodeRemoteValue //
  WindowProxyRemoteValue //
}

InternalId = js-uint;

ListRemoteValue = [*RemoteValue];

MappingRemoteValue = [*[(RemoteValue / text), RemoteValue]];

SymbolRemoteValue = {
  type: "symbol",
  ?handle: Handle,
  ?internalId: InternalId,
}

ArrayRemoteValue = {
  type: "array",
  ?handle: Handle,
  ?internalId: InternalId,
  ?value: ListRemoteValue,
}

ObjectRemoteValue = {
  type: "object",
  ?handle: Handle,
  ?internalId: InternalId,
  ?value: MappingRemoteValue,
}

FunctionRemoteValue = {
  type: "function",
  ?handle: Handle,
  ?internalId: InternalId,
}

RegExpRemoteValue = {
  RegExpLocalValue,
  ?handle: Handle,
  ?internalId: InternalId,
}

DateRemoteValue = {
  DateLocalValue,
  ?handle: Handle,
  ?internalId: InternalId,
}

MapRemoteValue = {
  type: "map",
  ?handle: Handle,
  ?internalId: InternalId,
  ?value: MappingRemoteValue,
}

SetRemoteValue = {
  type: "set",
  ?handle: Handle,
  ?internalId: InternalId,
  ?value: ListRemoteValue
}

WeakMapRemoteValue = {
  type: "weakmap",
  ?handle: Handle,
  ?internalId: InternalId,
}

WeakSetRemoteValue = {
  type: "weakset",
  ?handle: Handle,
  ?internalId: InternalId,
}

IteratorRemoteValue = {
  type: "iterator",
  ?handle: Handle,
  ?internalId: InternalId,
}

GeneratorRemoteValue = {
  type: "generator",
  ?handle: Handle,
  ?internalId: InternalId,
}

ErrorRemoteValue = {
  type: "error",
  ?handle: Handle,
  ?internalId: InternalId,
}

ProxyRemoteValue = {
  type: "proxy",
  ?handle: Handle,
  ?internalId: InternalId,
}

PromiseRemoteValue = {
  type: "promise",
  ?handle: Handle,
  ?internalId: InternalId,
}

TypedArrayRemoteValue = {
  type: "typedarray",
  ?handle: Handle,
  ?internalId: InternalId,
}

ArrayBufferRemoteValue = {
  type: "arraybuffer",
  ?handle: Handle,
  ?internalId: InternalId,
}

NodeRemoteValue = {
  type: "node",
  ?handle: Handle,
  ?internalId: InternalId,
  ?value: NodeProperties,
}

NodeProperties = {
  nodeType: js-uint,
  nodeValue: text,
  childNodeCount: js-uint,
  ?localName: text,
  ?namespaceURI: text,
  ?children: [*NodeRemoteValue],
  ?attributes: {*text => text},
  ?shadowRoot: NodeRemoteValue / null,
}

WindowProxyRemoteValue = {
  type: "window",
  ?handle: Handle,
  ?internalId: InternalId,
}
</pre>

Issue: Add WASM types?

Issue: Should WindowProxy get attributes in a similar style to Node?

Issue: Describe `IteratorRemoteValue` serialization.

Issue: Describe `GeneratorRemoteValue` serialization.

Issue: Describe `ProxyRemoteValue` serialization.

Issue: handle String / Number / etc. wrapper objects specially?

#### Serialization #### {#data-types-protocolValue-RemoteValue-serialization}

<div algorithm>

To <dfn>serialize as a remote value</dfn> given a |value|, a |max depth|,
an |ownership type|, a |serialization internal map| and a |realm|:

1. Let |remote value| be a result of [=serialize primitive protocol value=]
   given a |value|.

1. If |remote value| is not undefined, return |remote value|.

1. In the following list of conditions and associated steps, run the first set
   of steps for which the associated condition is true:

1. Let |handle id| be the [=handle for an object=] given |realm|, |ownership type|
   and |value|.

1. Let |known object| be <code>true</code>, if |value| is in the
   |serialization internal map|, otherwise <code>false</code>.

1. Let |child ownership| be "<code>none</code>".

  <dl>
    <dt>[=Type=](|value|) is Symbol
    <dd>Let |remote value| be a map matching the <code>SymbolRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>[=IsArray=](|value|)
    <dd>

    1. Let |remote value| be a map matching the <code>ArrayRemoteValue</code>
       production in the [=local end definition=], with the <code>handle</code>
       property set to |handle id| if it's not null, or omitted otherwise.

    1. [=Set internal ids if needed=] given |serialization internal map|,
       |remote value| and |value|.

    1. Let |serialized| be null.

    1. If |known object| is <code>false</code>, and |max depth| is not null and
       greater than 0, run the following steps:

           1. Let |serialized| be the result of [=serialize as a list=] given
              [=CreateArrayIterator=](|value|, value), |max depth|, |child ownership|,
              |serialization internal map| and |realm|.

    1. If |serialized| is not null, set field <code>value</code> of |remote value| to
       |serialized|.

    <dt>[=IsRegExp=](|value|)
    <dd>
    1. Let |pattern| be [=ToString=]([=Get=](|value|, "source")).

    1. Let |flags| be [=ToString=]([=Get=](|value|, "flags")).

    1. Let |value| be a map matching the <code>RegExpValue</code> production in the
       [=local end definition=], with the <code>pattern</code> property set to the
       |pattern| and the the <code>flags</code> property set to the |flags|.

    1. Let |remote value| be a map matching the <code>RegExpRemoteValue</code>
       production in the [=local end definition=], with the <code>handle</code>
       property set to |handle id| if it's not null, or omitted otherwise, and
       the <code>value</code> property set to |value|.

    <dt>|value| has a \[[DateValue]] [=internal slot=].
    <dd>
    1. Set |serialized| to [=Call=]([=Date.toISOString=], |value|).

    1. Assert: |serialized| is not a [=throw completion=].

    1. Let |remote value| be a map matching the <code>DateRemoteValue</code>
       production in the [=local end definition=], with the <code>handle</code>
       property set to |handle id| if it's not null, or omitted otherwise, and the
       value set to |serialized|.

    <dt>|value| has a \[[MapData]] [=internal slot=]
    <dd>

    1. Let |remote value| be a map matching the <code>MapRemoteValue</code>
       production in the [=local end definition=], with the
       <code>handle</code> property set to |handle id| if it's not null, or omitted
       otherwise.

    1. [=Set internal ids if needed=] given |serialization internal map|,
       |remote value| and |value|.

    1. Let |serialized| be null.

    1. If |known object| is <code>false</code>, and |max depth| is not null and
       greater than 0, run the following steps:

       1. Let |serialized| be the result of [=serialize as a mapping=] given
          [=CreateMapIterator=](|value|, key+value), |max depth|,
          |child ownership|, |serialization internal map| and |realm|.

    1. If |serialized| is not null, set field <code>value</code> of |remote value| to
       |serialized|.

    <dt>|value| has a \[[SetData]] [=internal slot=]
    <dd>
    1. Let |remote value| be a map matching the <code>SetRemoteValue</code>
       production in the [=local end definition=], with the
       <code>handle</code> property set to |handle id| if it's not null, or omitted
       otherwise.

    1. [=Set internal ids if needed=] given |serialization internal map|,
       |remote value| and |value|.

    1. Let |serialized| be null.

    1. If |known object| is <code>false</code>, and |max depth| is not null and
       greater than 0, run the following steps:

       1. Let |serialized| be the result of [=serialize as a list=] given
          [=CreateSetIterator=](|value|, value), |max depth|, |child ownership|,
          |serialization internal map| and |realm|.

    1. If |serialized| is not null, set field <code>value</code> of |remote value| to
       |serialized|.

    <dt>|value| has a \[[WeakMapData]] [=internal slot=]
    <dd>Let |remote value| be a map matching the <code>WeakMapRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>|value| has a \[[WeakSetData]] [=internal slot=]
    <dd>Let |remote value| be a map matching the <code>WeakSetRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>|value| has an \[[ErrorData]] [=internal slot=]
    <dd>Let |remote value| be a map matching the <code>ErrorRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>[=IsPromise=](|value|)
    <dd>Let |remote value| be a map matching the <code>PromiseRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>|value| has a \[[TypedArrayName]] [=internal slot=]
    <dd>Let |remote value| be a map matching the <code>TypedArrayRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>|value| has an \[[ArrayBufferData]] [=internal slot=]
    <dd>Let |remote value| be a map matching the <code>ArrayBufferRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>|value| is a [=platform object=] that implements [=Node=]
    <dd>
      1. Let |remote value| be a map matching the <code>NodeRemoteValue</code>
         production in the [=local end definition=], with the <code>handle</code>
         property set to |handle id| if it's not null, or omitted otherwise.

      1. [=Set internal ids if needed=] given |serialization internal map|,
         |remote value| and |value|.

      1. Let |serialized| be null.

      1. If |known object| is <code>false</code>, run the following steps:

          1. Let |serialized| be a map.

          1. Set |serialized|["<code>nodeType</code>"] to [=Get=](|value|, "nodeType").

          1. Set |serialized|["<code>nodeValue</code>"] to [=Get=](|value|, "nodeValue")

          1. If |value| is an [=/Element=] or an <a spec=dom>Attribute</a>:

            1. Set |serialized|["<code>localName</code>"] to [=Get=](|value|, "localName").

            1. Set |serialized|["<code>namespaceURI</code>"] to [=Get=](|value|, "namespaceURI")

          1. Let |child node count| be the [=list/size=] of |serialized|'s [=children=].

          1. Set |serialized|["<code>childNodeCount</code>"] to |child node count|.

          1. If |max depth| is equal to 0 let |children| be null.
             Otherwise, let |children| be an empty list and, for each node
             |child| in the [=children=] of |value|:

            1. Let |child depth| be |max depth| - 1 if |max depth| is not null, or null otherwise.

            1. Let |serialized| be the result of [=serialize as a remote value=]
               with |child|, |child depth|, |child ownership|,
               |serialization internal map| and |realm|.

            1. Append |serialized| to |children|.

          1. Set |serialized|["<code>children</code>"] to |children|.

          1. If |value| is an [=/Element=]:

             1. Let |attributes| be a new map.

             1. For each |attribute| in |value|'s [=Element/attribute list=]:

               1. Let |name| be |attribute|'s [=Attr/qualified name=]

               1. Let |value| be |attribute|'s [=Attr/value=].

               1. Set |attributes|[|name|] to |value|

             1. Set |serialized|["<code>attributes</code>"] to |attributes|.

             1. Let |shadow root| be |value|'s [=Element/shadow root=].

             1. If |shadow root| is null, let |serialized shadow| be null.
                Otherwise run the following substeps:

               1.  Let |child depth| be |max depth| - 1 if |max depth| is not
                  null, or null otherwise.

               1. Let |serialized shadow| be the result of
                  [=serialize as a remote value=] with |shadow root|, |child depth|,
                  false, |child ownership|, |serialization internal map| and |realm|.

                Note: this means the <code>handle</code> for the shadow root
                will be serialized irrespective of whether the shadow is open or closed,
                but no properties of the node will be returned.

             1. Set |serialized|["<code>shadowRoot</code>"] to |serialized shadow|.

      1. If |serialized| is not null, set field <code>value</code> of |remote value| to
         |serialized|.

    <dt>|value| is a [=platform object=] that implements {{WindowProxy}}
    <dd>1. Let |remote value| be a map matching the <code>WindowProxyRemoteValue</code>
           production in the [=local end definition=], with the <code>handle</code>
           property set to |handle id| if it's not null, or omitted otherwise.

    <dt>|value| is a [=platform object=]
    <dd>1. Let |remote value| be a map matching the <code>ObjectRemoteValue</code>
           production in the [=local end definition=], with the <code>handle</code>
           property set to |handle id| if it's not null, or omitted otherwise.

    <dt>[=IsCallable=](|value|)
    <dd>Let |remote value| be a map matching the <code>FunctionRemoteValue</code>
        production in the [=local end definition=], with the <code>handle</code>
        property set to |handle id| if it's not null, or omitted otherwise.

    <dt>Otherwise:
    <dd>
    1. [=Assert=]: [=type=](|value|) is Object

    1. Let |remote value| be a map matching the <code>ObjectRemoteValue</code> production
       in the [=local end definition=], with the <code>handle</code> property set
       to |handle id| if it's not null, or omitted otherwise.

    1. [=Set internal ids if needed=] given |serialization internal map|,
       |remote value| and |value|.

    1. Let |serialized| be null.

    1. If |known object| is <code>false</code>, and |max depth| is greater than 0,
       run the following steps:

       1. Let |serialized| be the result of [=serialize as a mapping=] given
          [=EnumerableOwnPropertyNames=](|value|, key+value), |max depth|,
          |child ownership|, |serialization internal map| and
          |realm|.

    1. If |serialized| is not null, set field <code>value</code> of |remote value| to
       |serialized|.

  </dl>

1. Return |remote value|

Issue: Does it make sense to use the same depth parameter for nodes and objects
in general?

Issue: |children| and child nodes are different things. Either <code>childNodeCount</code> should
reference to <code>childNodes</code>, or it should be renamed to <code>childrenCount</code>.

Issue: <code>nodeValue</code> can be null. Omit the field in such a case, or adjust type to allow
null value.

Issue: <code>shadowRoot</code> field is optional. Omit it in case of |shadow root| is null, or
remove optional flag from the field.

</div>

<div algorithm>
To <dfn>serialize as a list</dfn> given |iterable|, |max depth|, |child ownership|,
|serialization internal map| and |realm|:

  1. Let |serialized| be a new list.

  1. For each |child value| in |iterable|:

    1. Let |child depth| be |max depth| - 1 if |max depth| is not null, or null
       otherwise.

    1. Let |serialized child| be the result of [=serialize as a remote value=]
       with arguments |child value|, |child depth|, |child ownership|,
       |serialization internal map| and |realm|.

    1. Append |serialized child| to |serialized|.

  1. Return |serialized|
</div>

Issue: this assumes for-in works on iterators

<div algorithm>
To <dfn>serialize as a mapping</dfn> given |iterable|, |max depth|,
|child ownership|, |serialization internal map| and |realm|:

1. Let |serialized| be a new list.

1. For |item| in |iterable|:

  1. Assert: [=IsArray=](|item|)

  1. Let |property| be [=CreateListFromArrayLike=](|item|)

  1. Assert: |property| is a list of [=list/size=] 2

  1. Let |key| be |property|[0] and let |value| be |property|[1]

  1. Let |child depth| be |max depth| - 1 if |max depth| is not null, or null
     otherwise.

  1. If [=Type=](|key|) is String, let |serialized key| be |child key|,
     otherwise let |serialized key| be the result of [=serialize as a remote value=]
     with arguments |child key|, |child depth|, |child ownership|,
     |serialization internal map| and |realm|.

  1. Let |serialized value| be the result of [=serialize as a remote value=]
     with arguments |value|, |child depth|, |child ownership|,
     |serialization internal map| and |realm|.

  1. Let |serialized child| be («|serialized key|, |serialized value|»).

  1. Append |serialized child| to |serialized|.

1. Return |serialized|

</div>

# Modules # {#modules}

## The session Module ## {#module-session}

The <dfn export for=modules>session</dfn> module contains commands and
events for monitoring the status of the remote end.

### Definition ### {#module-session-definition}

[=remote end definition=]

<pre class="cddl remote-cddl">
SessionCommand = (
  SessionNewCommand //
  SessionStatusCommand //
  SessionSubscribeCommand //
  SessionUnsubscribeCommand
)
</pre>

[=local end definition=]

<pre class="cddl local-cddl">
SessionResult = (SessionStatusResult)
</pre>

<div algorithm>

To <dfn>update the event map</dfn>, given
|session|, |requested event names|, |browsing contexts|, and |enabled|:

Note: The return value of this algorithm is a map between event names and
contexts. When the events are being enabled, the contexts in the return value
are those for which the event are now enabled but were not previously. When
events are disabled, the return value is always empty.

1. Let |global event set| be a [=set/clone=] of the [=global event set=] for
   |session|.

1. Let |event map| be a new map.

1. For each |key| → |value| of the [=browsing context event map=] for
   |session|:

  1. Set |event map|[|key|] to a [=set/clone=] of |value|.

1. Let |event names| be an empty set.

1. For each entry |name| in |requested event names|,
   let |event names| be the union of |event names| and the result of
   [=trying=] to [=obtain a set of event names=] with |name|.

1. Let |enabled events| be a new map.

1. If |browsing contexts| is null:

    1. If |enabled| is true:

      1. For each |event name| of |event names|:

         1. If |global event set| doesn't contain |event name|:

           1. Let |already enabled contexts| be the [=event enabled browsing
              contexts=] given |session| and |event name|

           1. Add |event name| to |global event set|.

           1. For each |context| of |already enabled contexts|, remove |event
              name| from |event map|[|context|].

           1. Let |newly enabled contexts| be a list of all [=top-level browsing
              contexts=] that are not contained in |already enabled contexts|,

           1. Set |enabled events|[|event name|] to |newly enabled contexts|.

    1. If |enabled| is false:

      1. For each |event name| in |event names|:

        1. If |global event set| [=contains=] |event name|, remove |event
           name| from |global event set|. Otherwise return [=error=] with
           [=error code=] [=invalid argument=].

1. Otherwise, if |browsing contexts| is not null:

  1. Let |targets| be an empty map.

  1. For each |context id| in |browsing contexts|:

    1. Let |context| be the result of [=trying=] to [=get a browsing context=]
       with |context id|.

    1. Let |top-level context| be the [=top-level browsing context=] for |context|.

    1. If |event map| does not contain |top-level context|, set |event
       map|[|top-level context|] to a new set.

    1. Set |targets|[|top-level context|] to |event map|[|top-level context|].

  1. For each |event name| in |event names|:

    1. If |enabled| is true and |global event set| contains |event name|, continue.

    1. For each |context| → |target| in |targets|:

      1. If |enabled| is true and |target| does not contain |event name|:

        1. Add |event name| to |target|.

        1. If |enabled events| does not contain |event name|, set |enabled
           events|[|event name|] to a new set.

        1. Append |context| to |enabled events|[|event name|].

      1. If |enabled| is false:

        1. If |target| contains |event name|, remove |event name| from
           |target|. Otherwise return [=error=] with [=error code=] [=invalid
           argument=].

1. Set the [=global event set=] for |session| to |global event set|.

1. Set the [=browsing context event map=] for |session| to |event map|.

1. Return [=success=] with data |enabled events|.

Note: Implementations that do additional work when an event is enabled,
e.g. subscribing to the relevant engine-internal events, will likely perform
those additional steps when updating the event map. This specification uses
a model where hooks are always called and then the event map is used to
filter only those that ought to be returned to the local end.

</div>

### Types ### {#module-session-types}

#### The session.CapabilitiesRequest Type #### {#type-session-capabilitiesRequest}

[=remote end definition=] and [=local end definition=]

<pre class="cddl remote-cddl local-cddl">
CapabilitiesRequest = {
  ?acceptInsecureCertificates: bool,
  ?browserName: text,
  ?browserVersion: text,
  ?platformName: text,
  ?proxy: {
    ?proxyType: "pac" / "direct" / "autodetect" / "system" / "manual",
    ?proxyAutoconfigUrl: text,
    ?ftpProxy: text,
    ?httpProxy: text,
    ?noProxy: [*text],
    ?sslProxy: text,
    ?socksProxy: text,
    ?socksVersion: 0..255,
  },
  Extensible
};
</pre>

The <code>CapabilitiesRequest</code> type represents the capabilities requested
for a session.


### Commands ### {#module-session-commands}

#### The session.status Command #### {#command-session-status}

The <dfn export for=commands>session.status</dfn> command returns information about
whether a remote end is in a state in which it can create new sessions,
but may additionally include arbitrary meta information that is specific
to the implementation.

This is a [=static command=].

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      SessionStatusCommand = {
        method: "session.status",
        params: EmptyParams,
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
      <pre class="cddl local-cddl">
      SessionStatusResult = {
        ready: bool,
        message: text,
      }
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for session.status">

The [=remote end steps=] given <var ignore>session</var>, and <var
ignore>command parameters</var> are:

1. Let |body| be a new [=map=] with the following properties:

   <dl>
      <dt>"ready"</dt>
      <dd>The [=remote end=]’s [=readiness state=].</dd>

      <dt>"message"</dt>
      <dd>An implementation-defined string explaining the [=remote end=]’s
      [=readiness state=].</dd>
   </dl>

1. Return [=success=] with data |body|

</div>

#### The session.new Command #### {#command-session-new}

The <dfn export for=commands>session.new</dfn> command allows creating a new
[=BiDi session=].

Note: A session created this way will not be accessible via HTTP.

This is a [=static command=].

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      SessionNewCommand = {
        method: "session.new",
        params: {capabilities: CapabilitiesRequestParameters},
      }

      CapabilitiesRequestParameters = {
        ?alwaysMatch: CapabilitiesRequest,
        ?firstMatch: [*CapabilitiesRequest]
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
      <pre class="cddl local-cddl">
      SessionNewResult = {
        sessionId: text,
        capabilities: {
          acceptInsecureCertificates: bool,
          browserName: text,
          browserVersion: text,
          platformName: text,
          proxy: {
            ?proxyType: "pac" / "direct" / "autodetect" / "system" / "manual",
            ?proxyAutoconfigUrl: text,
            ?ftpProxy: text,
            ?httpProxy: text,
            ?noProxy: [*text],
            ?sslProxy: text,
            ?socksProxy: text,
            ?socksVersion: 0..255,
          },
          setWindowRect: bool,
          Extensible
        }
      }
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for session.new">

The [=remote end steps=] given |session| and |command parameters| are:

1. If |session| is not null, return an [=error=] with error code [=session not created=].

1. If the implementation is unable to start a new session for any reason, return
   an [=error=] with error code [=session not created=].

1. Let |flags| be a set containing "<code>bidi</code>".

1. Let |capabilities| be the result of [=trying=] to [=process capabilities=]
   with |command parameters| and |flags|.

1. Let |session| be the result of [=trying=] to [=create a session=] with
   |capabilities| and |flags|.

1. Set |session|'s [=BiDi flag=] to true.

   Note: the connection for this session will be set to the current connection
   by the caller.

1. Let |body| be a new map matching the <code>SessionNewResult</code> production,
   with the <code>sessionId</code> field set to |session|'s [=session ID=], and
   the <code>capabilities</code> field set to |capabilities|.

1. Return [=success=] with data |body|.

</div>

#### The session.subscribe Command #### {#command-session-subscribe}

The <dfn export for=commands>session.subscribe</dfn> command enables certain events
either globally or for a set of browsing contexts

Issue: This needs to be generalized to work with realms too

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      SessionSubscribeCommand = {
        method: "session.subscribe",
        params: SessionSubscribeParameters
      }

      SessionSubscribeParameters = {
        events: [*text],
        ?contexts: [*BrowsingContext],
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
      <pre class="cddl">
      EmptyResult
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for session.subscribe">
The [=remote end steps=] with |session| and |command parameters| are:

1. Let the |list of event names| be the value of the <code>events</code> field of
   |command parameters|

1. Let the |list of contexts| be the value of the <code>contexts</code>
   field of |command parameters| if it is present or null if it isn't.

1. Let |enabled events| be the result of [=trying=] to [=update the event map=]
   with |session|, |list of event names| , |list of contexts| and
   enabled true.

1. Let |subscribe step events| be a new map.

1. For each |event name| → |contexts| in |enabled events|:

  1. If the [=event=] with [=event name=] |event name| defines [=remote end
     subscribe steps=], set |subscribe step events|[|event name|] to |contexts|.

1. [=map/Sort in ascending order=] |subscribe step events| using the following less
   than algorithm given two entries with keys |event name one| and |event
   name two|:

    1. Let |event one| be the [=event=] with name |event name one|

    1. Let |event two| be the [=event=] with name |event name two|

    1. Return true if |event one|'s [=subscribe priority=] is less than |event
       two|'s subscribe priority, or false otherwise.

1. If |list of contexts| is null, let |include global| be true, otherwise let
   |include global| be false.

1. For each |event name| → |contexts| in |subscribe step events|:

  1. Run the [=remote end subscribe steps=] for the [=event=] with [=event name=]
     |event name| given |session|, |contexts| and |include global|.

1. Return [=success=] with data null.

</div>

#### The session.unsubscribe Command #### {#command-session-unsubscribe}

The <dfn export for=commands>session.unsubscribe</dfn> command disables events
either globally or for a set of browsing contexts

Issue: This needs to be generalised to work with realms too

<dl>
   <dt>Command Type</dt>
   <dd>
     <pre class="cddl remote-cddl">
     SessionUnsubscribeCommand = {
       method: "session.unsubscribe",
       params: SessionSubscribeParameters
     }
     </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
      <pre class="cddl">
      EmptyResult
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for session.unsubscribe">
The [=remote end steps=] with |session| and |command parameters| are:

1. Let the |list of event names| be the value of the <code>events</code> field of
   |command parameters|.

1. Let the |list of contexts| be the value of the <code>contexts</code>
   field of |command parameters| if it is present or null if it isn't.

1. [=Try=] to [=update the event map=] with |session|,
   |list of event names|, |list of contexts| and enabled false.

1. Return [=success=] with data null.

</div>


## The browsingContext Module ## {#module-browsingContext}

The <dfn export for=modules>browsingContext</dfn> module contains commands and
events relating to browsing contexts.

The progress of navigation is communicated using an immutable <dfn export>WebDriver
navigation status</dfn> struct, which has the following items:

<dl>
  <dt><dfn export id="navigation-status-id">id</dfn></dt>
  <dd>The [=navigation id=] for the navigation, or null when the navigation is
  canceled before making progress.</dd>

  <dt><dfn export id="navigation-status-status">status</dfn></dt>
    <dd>A status code that is either
      "<dfn export id="navigation-status-canceled"><code>canceled</code></dfn>",
      "<dfn export id="navigation-status-pending"><code>pending</code></dfn>", or
      "<dfn export id="navigation-status-complete"><code>complete</code></dfn>".
    </dd>

  <dt><dfn export id="navigation-status-url">url</dfn></dt>
  <dd>The URL which is being loaded in the navigation</dd>
</dl>

### Definition ### {#module-browsingContext-definition}

[=remote end definition=]

<pre class="cddl remote-cddl">
BrowsingContextCommand = (
  BrowsingContextCaptureScreenshotCommand //
  BrowsingContextCloseCommand //
  BrowsingContextCreateCommand //
  BrowsingContextGetTreeCommand //
  BrowsingContextHandleUserPromptCommand //
  BrowsingContextNavigateCommand //
  BrowsingContextReloadCommand
)
</pre>

[=local end definition=]

<pre class="cddl local-cddl">
BrowsingContextResult = (
  BrowsingContextCaptureScreenshotResult //
  BrowsingContextCreateResult //
  BrowsingContextGetTreeResult //
  BrowsingContextNavigateResult
)

BrowsingContextEvent = (
  BrowsingContextCreatedEvent //
  BrowsingContextDestroyedEvent //
  BrowsingContextNavigationStartedEvent //
  BrowsingContextFragmentNavigatedEvent //
  BrowsingContextDomContentLoadedEvent //
  BrowsingContextLoadEvent //
  BrowsingContextDownloadWillBeginEvent //
  BrowsingContextNavigationAbortedEvent //
  BrowsingContextNavigationFailedEvent //
  BrowsingContextUserPromptClosedEvent //
  BrowsingContextUserPromptOpenedEvent
)
</pre>

### Types ### {#module-browsingcontext-types}

#### The browsingContext.BrowsingContext Type #### {#type-browsingContext-Browsingcontext}

[=remote end definition=] and [=local end definition=]

<pre class="cddl remote-cddl local-cddl">
BrowsingContext = text;
</pre>

Each [=/browsing context=] has an associated <dfn export>browsing context
id</dfn>, which is a string uniquely identifying that browsing context. This is
implicitly set when the context is created. For browsing contexts with an
associated WebDriver [=window handle=] the [=/browsing context id=] must be the
same as the [=window handle=].

<div algorithm>
To <dfn>get a browsing context</dfn> given |context id|:

1. If |context id| is null, return [=success=] with data null.

1. If there is no browsing context with [=browsing context id=] |context id| return
   [=error=] with [=error code=] [=no such frame=]

1. Let |context| be the browsing context with id |context id|.

1. Return [=success=] with data |context|

</div>

#### The browsingContext.BrowsingContextInfo Type #### {#type-browsingContext-BrowsingContextInfo}

[=local end definition=]

<pre class="cddl local-cddl">
BrowsingContextInfoList = [* BrowsingContextInfo]

BrowsingContextInfo = {
  context: BrowsingContext,
  url: text,
  children: BrowsingContextInfoList / null
  ?parent: BrowsingContext / null,
}
</pre>

The <code>BrowsingContextInfo</code> type represents the properties of a
browsing context.

<div algorithm>
To <dfn>get the browsing context info</dfn> given |context|,
|max depth| and |is root|:

1. Let |context id| be the [=browsing context id=] for |context|.

1. If |context| has a [=parent browsing context=] let |parent id| be the
   [=browsing context id=] of that parent. Otherwise let |parent id| be null.

1. Let |document| be |context|'s [=active document=].

1. Let |url| be the result of running the [=URL serializer=], given
   |document|'s <a spec=dom>URL</a>.

   Note: This includes the fragment component of the URL.

1. Let |child infos| be null.

1. If |max depth| is null, or |max depth| is greater than 0:

  1. Let |child contexts| be a list containing all [=/browsing contexts=]
     which are [=child browsing contexts=] of |context|.

  1. Let |child depth| be |max depth| - 1 if |max depth| is not null, or null otherwise.

  1. Set |child infos| to an empty list

  1. For each |context| of |child contexts|:

    1. Let |info| be the result of [=get the browsing context info=] given
       |context|, |child depth|, and false.

    1. Append |info| to |child infos|

1. Let |context info| be a [=map=] matching the
   <code>BrowsingContextInfo</code> production with the <code>context</code>
   field set to |context id|, the <code>parent</code> field set to |parent id|
   if |is root| is <code>true</code>, or unset otherwise, the <code>url</code>
   field set to |url|, and the <code>children</code> field set to |child infos|.

1. Return |context info|.

</div>

<div algorithm>
To <dfn>await a navigation</dfn> given |context|, |request|, |wait condition|, and optionally
|history handling| (default: "<code>default</code>") and |ignore cache| (default: false):

1. Let |navigation id| be the string representation of a
   [[!RFC4122|UUID]] based on truly random, or pseudo-random numbers.

1. [=Navigate=] |context| with resource |request|, and using |context| as the
   [=source browsing context=], with [=navigation id=] |navigation id|, and
   [=history handling behavior=] |history handling|. If |ignore cache| is true, the
   navigation must not load resources from the HTTP cache.

   Issue: property specify how the |ignore cache| flag works. This needs to
   consider whether only the first load of a resource bypasses the cache
   (i.e. whether this is like initially clearing the cache and proceeding like
   normal), or whether resources not directly loaded by the HTML parser
   (e.g. loads initiated by scripts or stylesheets) also bypass the cache.

1.  Let (|event received|, |navigate status|) be [=await=] given
    «"<code>navigation started</code>", "<code>navigation failed</code>",
    "<code>fragment navigated</code>"», and |navigation id|.

1. Assert: |navigate status|'s id is |navigation id|.

1. If |navigate status|'s status is "<code>complete</code>":

  1. Let |body| be a [=map=] matching the
     <code>BrowsingContextNavigateResult</code> production, with the
     <code>navigation</code> field set to |navigation id|, and the
     <code>url</code> field set to the result of the [=URL serializer=] given
     |navigate status|'s url.

  1. Return [=success=] with data |body|.

   Note: this is the case if the navigation only caused the fragment to
   change.

1. If |navigate status|'s status is "<code>canceled</code>" return [=error=]
   with [=error code=] [=unknown error=].

   TODO: is this the right way to handle errors here?

1. Assert: |navigate status|'s status is "<code>pending</code>" and
   |navigation id| is not null.

1. If |wait condition| is "<code>none</code>":

  1. Let |body| be a [=map=] matching the
     <code>BrowsingContextNavigateResult</code> production, with the
     <code>navigation</code> field set to |navigation id|, and the
     <code>url</code> field set to the result of the [=URL serializer=] given
     |navigate status|'s url.

  1. Return [=success=] with data |body|.

1. If |wait condition| is "<code>interactive</code>", let |event name| be
   "<code>domContentLoaded</code>", otherwise let |event name| be
   "<code>load</code>".

1. Let (|event received|, |status|) be [=await=] given «|event name|,
    "<code>download started</code>", "<code>navigation aborted</code>",
    "<code>navigation failed</code>"» and |navigation id|.

1. If |event received| is "<code>navigation failed</code>"
   return [=error=] with [=error code=] [=unknown error=].

   Issue: Are we surfacing enough information about what failed and why with
   an error here? What error code do we want? Is there going to be a problem
   where local ends parse the implementation-defined strings to figure out
   what actually went wrong?

1. Let |body| be a [=map=] matching the
   <code>BrowsingContextNavigateResult</code> production, with the
   <code>navigation</code> field set to |status|'s id, and the
   <code>url</code> field set to the result of the [=URL serializer=] given
   |status|'s url.

1. Return [=success=] with data |body|.


</div>

#### The browsingContext.Navigation Type #### {#type-browsingContext-Navigation}

[=remote end definition=] and [=local end definition=]

<pre class="cddl remote-cddl local-cddl">
Navigation = text;
</pre>

The <code>Navigation</code> type is a unique string identifying an ongoing
navigation.

TODO: Link to the definition in the HTML spec.


#### The browsingContext.NavigationInfo Type #### {#type-browsingContext-NavigationInfo}

[=local end definition=]:

<pre class="cddl local-cddl">
NavigationInfo = {
  context: BrowsingContext,
  navigation: Navigation / null,
  url: text,
}
</pre>

The <code>NavigationInfo</code> type provides details of an ongoing navigation.

<div algorithm>
To <dfn>get the navigation info</dfn>, given |context| and |navigation status|:

1. Let |context id| be the [=browsing context id=] for |context|.

1. Let |navigation id| be |navigation status|'s id.

1. Let |url| be |navigation status|'s url.

1. Return a [=map=] matching the
   <code>NavigationInfo</code> production, with the
   <code>context</code> field set to |context id|, the <code>navigation</code>
   field set to |navigation id|, and the <code>url</code> field set to the
   result of the [=URL serializer=] given |url|.

</div>

### Commands ### {#module-browsingContext-commands}

#### The browsingContext.captureScreenshot Command ####  {#command-browsingContext-captureScreenshot}

The <dfn export for=commands>browsingContext.captureScreenshot</dfn> command
captures an image of the given browsing context, and returns it as a
Base64-encoded string.


<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      BrowsingContextCaptureScreenshotCommand = {
        method: "browsingContext.captureScreenshot",
        params: BrowsingContextCaptureScreenshotParameters
      }

      BrowsingContextCaptureScreenshotParameters = {
        context: BrowsingContext
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
    <pre class="cddl local-cddl">
        BrowsingContextCaptureScreenshotResult = {
          data: text
        }
    </pre>
   </dd>
</dl>

TODO: Full page screenshots, and multiple output formats

The [=remote end steps=] with <var ignore>session</var> and |command parameters| are:

1. Let |context id| be the value of the <code>context</code> field of
   |command parameters|.

1. Let |context| be the result of [=trying=] to [=get a browsing context=]
   with |context id|.

1. If the implementation is unable to capture a screenshot of |context| for any
   reason then return [=error=] with [=error code=] [=unsupported operation=].

1. Let |document| be |context|'s [=active document=].

1. Immediately after the next invocation of the [=run the animation frame
   callbacks=] algorithm for |document|:

   Issue: This ought to be integrated into the update rendering algorithm
   in some more explicit way.

 1. Let |root rect| be |document|’s [=document element=]'s [=rectangle=].

 1. Let |canvas| be the result of [=trying=] to [=draw a bounding box from the
    framebuffer=] with |root rect|.

 1. Let |encoding result| be the result of [=trying=] to [=encode a canvas as
    Base64=] with |canvas|.

 1. Let |body| be a [=map=] matching the
    <code>BrowsingContextCaptureScreenshotResult</code> production, with the
    <code>data</code> field set to |encoding result|.

 1. Return [=success=] with data |body|.

#### The browsingContext.close Command ####  {#command-browsingContext-close}

The <dfn export for=commands>browsingContext.close</dfn> command closes a
[=top-level browsing context=].

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      BrowsingContextCloseCommand = {
        method: "browsingContext.close",
        params: BrowsingContextCloseParameters
      }

      BrowsingContextCloseParameters = {
        context: BrowsingContext
      }
      </pre>
   </dd>

   <dt>Return Type</dt>
   <dd>
      <pre class="cddl">
      EmptyResult
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for browsingContext.close">
The [=remote end steps=] with |command parameters| are:

  1. Let |context id| be the value of the <code>context</code> field of
     |command parameters|.

  1. Let |context| be the result of [=trying=] to [=get a browsing context=]
     with |context id|.

  1. Assert: |context| is not null.

  1. If |context| is not a [=top-level browsing context=], return [=error=] with
     [=error code=] [=invalid argument=].

  1. [=Close=] |context|.

Issue(w3c/webdriver-bidi#170): There is an open discussion about the behavior
when closing the last [=top-level browsing context=]. We could expect to close
the browser, close the session or leave this up to the implementation.

</div>

#### The browsingContext.create Command ####  {#command-browsingContext-create}

The <dfn export for=commands>browsingContext.create</dfn> command creates a new
[=/browsing context=], either in a new tab or in a new window, and returns its
[=browsing context id=].

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      BrowsingContextCreateCommand = {
        method: "browsingContext.create",
        params: BrowsingContextCreateParameters
      }

      BrowsingContextCreateType = "tab" / "window"

      BrowsingContextCreateParameters = {
        type: BrowsingContextCreateType,
        ?referenceContext: BrowsingContext
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
    <pre class="cddl local-cddl">
        BrowsingContextCreateResult = {
          context: BrowsingContext
        }
    </pre>
   </dd>
</dl>

<div algorithm="remote end steps for browsingContext.create">
The [=remote end steps=] with |command parameters| are:

  1. Let |type| be the value of the <code>type</code> field of
     |command parameters|.

  1. Let |reference context id| be the value of the <code>referenceContext</code>
     field of |command parameters|, if present, or null otherwise.

  1. If |reference context id| is not null, let |reference context| be the
     result of [=trying=] to [=get a browsing context=] with
     |reference context id|. Otherwise let |reference context| be null.

  1. If |reference context| is not null and is not a [=top-level browsing context=],
    return [=error=] with [=error code=] [=invalid argument=].

  1. If the implementation is unable to create a new browsing context for any
     reason then return [=error=] with [=error code=] [=unsupported operation=].

  <!-- This is based on step 5 of https://w3c.github.io/webdriver/#new-window,
       but without using the "current browsing context" concept. -->
  1. Create a new [=top-level browsing context=] by running the [=window open
     steps=] with <var ignore>url</var> set to "<code>about:blank</code>",
     <var ignore>target</var> set to the empty string, and
     <var ignore>features</var> set to "<code>noopener</code>". This must be
     done without invoking the [=/focusing steps=] for the created browsing
     context. Which OS window the new [=/browsing context=] is created in
     depends on |type| and |reference context|:

     * If |type| is "<code>tab</code>" and the implementation supports
       multiple browsing contexts in the same OS window:

       * The new browsing context should reuse an existing OS window, if any.

       * If |reference context| is not null, the new browsing context should
         reuse the window containing |reference context|, if any. If the
         top-level browsing contexts inside an OS window have a definite ordering,
         the new browsing context should be immediately after
         |reference context|'s [=top-level browsing context=] in that ordering.

     * If |type| is "<code>window</code>", and the implementation supports
       multiple browsing contexts in separate OS windows, the created browsing
       context should be in a new OS window.

     * Otherwise, the details of how the browsing context is presented to the
       user are implementation defined.

  1. Let |context id| be the [=browsing context id=] of the newly created
     [=/browsing context=].

  1. Let |body| be a [=map=] matching the <code>BrowsingContextCreateResult</code>
     production, with the <code>context</code> field set to |context id|.

  1. Return [=success=] with data |body|.

</div>

#### The browsingContext.getTree Command ####  {#command-browsingContext-getTree}

The <dfn export for=commands>browsingContext.getTree</dfn> command returns a
tree of all descendent browsing contexts including the given parent itself,
or all top-level contexts when no parent is provided.

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      BrowsingContextGetTreeCommand = {
        method: "browsingContext.getTree",
        params: BrowsingContextGetTreeParameters
      }

      BrowsingContextGetTreeParameters = {
        ?maxDepth: js-uint,
        ?root: BrowsingContext,
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
    <pre class="cddl local-cddl">
        BrowsingContextGetTreeResult = {
          contexts: BrowsingContextInfoList
        }
    </pre>
   </dd>
</dl>

<div algorithm="remote end steps for browsingContext.getTree">
The [=remote end steps=] with <var ignore>session</var> and |command parameters| are:

1. Let |root id| be the value of the <code>root</code> field of
   |command parameters| if present, or null otherwise.

1. Let |max depth| be the value of the <code>maxDepth</code> field of |command
   parameters| if present, or null otherwise.

1. Let |contexts| be an empty list.

1. If |root id| is not null, append the result of [=trying=] to
   [=get a browsing context=] given |root id| to |contexts|.
   Otherwise append all [=top-level browsing contexts=] to |contexts|.

1. Let |contexts info| be an empty list.

1. For each |context| of |contexts|:

  1. Let |info| be the result of [=get the browsing context info=] given
     |context|, |max depth|, and true.

  1. Append |info| to |contexts info|

1. Let |body| be a [=map=] matching the <code>BrowsingContextGetTreeResult</code>
   production, with the <code>contexts</code> field set to |contexts info|.

1. Return [=success=] with data |body|.

</div>

#### The browsingContext.handleUserPrompt Command ####  {#command-browsingContext-handleUserPrompt}

The <dfn export for=commands>browsingContext.handleUserPrompt</dfn>
command allows closing an open prompt

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      BrowsingContextHandleUserPromptCommand = {
        method: "browsingContext.handleUserPrompt",
        params: BrowsingContextHandleUserPromptParameters
      }

      BrowsingContextHandleUserPromptParameters = {
        context: BrowsingContext,
        ? accept: bool,
        ? userText: text,
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
      <pre class="cddl">
      EmptyResult
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for browsingContext.handleUserPrompt">

1. Let |context id| be the value of the <code>context</code> field of
   |command parameters|.

1. Let |context| be the result of [=trying=] to [=get a browsing context=]
   with |context id|.

1. Let |accept| be the value of the <code>accept</code> field of |command
   parameters| if present, or true otherwise.

1. Let |text| be the value of the <code>text</code> field of |command
   parameters| if present, or the empty string otherwise.

1. If |context| is currently showing a simple dialog from a call to [=alert=] then
   acknowledge the prompt.

   Otherwise if |context| is currently showing a simple dialog from a call to
   [=confirm=], then respond positively if |accept| is true, or respond
   negatively if |accept| is false.

   Otherwise if |context| is currently showing a simple dialog from a call to
   [=prompt=], then respond with the string value |text| if |accept| is
   true, or abort if |accept| is false.

   Otherwise, if |context| is currently showing a prompt as part of the [=prompt
   to unload=] steps, then confirm the navigation if |accept| is true, otherwise
   refuse the navigation.

   Otherwise return [=error=] with [=error code=] [=no such alert=].

1. Return [=success=] with data null.

</div>

#### The browsingContext.navigate Command ####  {#command-browsingContext-navigate}

The <dfn export for=commands>browsingContext.navigate</dfn> command navigates a
browsing context to the given URL.

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      BrowsingContextNavigateCommand = {
        method: "browsingContext.navigate",
        params: BrowsingContextNavigateParameters
      }

      BrowsingContextNavigateParameters = {
        context: BrowsingContext,
        url: text,
        ?wait: ReadinessState,
      }

       ReadinessState = "none" / "interactive" / "complete"
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
    <pre class="cddl local-cddl">
        BrowsingContextNavigateResult = {
          navigation: Navigation / null,
          url: text,
        }
    </pre>
   </dd>
</dl>

<div algorithm="remote end steps for browsingContext.navigate">
The [=remote end steps=] with <var ignore>session</var> and |command parameters| are:

1. Let |context id| be the value of the <code>context</code> field of
   |command parameters|.

1. Let |context| be the result of [=trying=] to [=get a browsing context=]
   with |context id|.

1. Assert: |context| is not null.

1. Let |wait condition| be the value of the <code>wait</code> field of |command
   parameters| if present, or "<code>none</code>" otherwise.

1. Let |url| be the value of the <code>url</code> field of |command
   parameters|.

1. Let |document| be |context|'s [=active document=].

1. Let |base| be |document|'s [=base URL=].

1. Let |url record| be the result of applying the [=URL parser=] to |url|,
   with [=base URL=] |base|.

1. If |url record| is failure, return [=error=] with [=error code=] [=invalid
   argument=].

1. Let |request| be a new [=/request=] whose URL is |url record|.

1. Return the result of [=await a navigation=] with |context|, |request| and
   |wait condition|.

</div>

#### The browsingContext.reload Command ####  {#command-browsingContext-reload}

The <dfn export for=commands>browsingContext.reload</dfn> command reloads a
browsing context.

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      BrowsingContextReloadCommand = {
        method: "browsingContext.reload",
        params: BrowsingContextReloadParameters
      }

      BrowsingContextReloadParameters = {
        context: BrowsingContext,
        ?ignoreCache: bool,
        ?wait: ReadinessState,
      }
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for browsingContext.reload">
The [=remote end steps=] with |command parameters| are:

1. Let |context id| be the value of the <code>context</code> field of
   |command parameters|.

1. Let |context| be the result of [=trying=] to [=get a browsing context=]
   with |context id|.

1. Assert: |context| is not null.

1. Let |ignore cache| be the the value of the <code>ignoreCache</code> field of |command
   parameters| if present, or false otherwise.

1. Let |wait condition| be the value of the <code>wait</code> field of |command
   parameters| if present, or "<code>none</code>" otherwise.

1. Let |document| be |context|'s [=active document=].

1. Let |url| be |document|'s <a spec=DOM>URL</a>.

1. Let |request| be a new [=/request=] whose URL is |url|.

1. Return the result of [=await a navigation=] with |context|, |request|, |wait
   condition|, history handling "<code>reload</code>", and ignore
   cache |ignore cache|.

</div>


### Events ### {#module-contexts-events}

#### The browsingContext.contextCreated Event #### {#event-browsingContext-contextCreated}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextCreatedEvent = {
         method: "browsingContext.contextCreated",
         params: BrowsingContextInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>

To <dfn>Recursively emit context created events</dfn> given |session| and |context|:

1. [=Emit a context created event=] with |session| and |context|.

1. For each child browsing context, |child|, of |context|:

  1. [=Recursively emit context created events=] given |session| and |child|.

</div>

<div algorithm>

To <dfn>Emit a context created event</dfn> given |session| and |context|:

1. Let |params| be the result of [=get the browsing context info=] given
   |context|, 0, and true.

1. Let |body| be a [=map=] matching the
   <code>BrowsingContextCreatedEvent</code> production, with the
   <code>params</code> field set to |params|.

1. [=Emit an event=] with |session| and |body|.

</div>

<div algorithm="remote end event trigger for browsingContext.contextCreated">

The [=remote end event trigger=] is:

When the [=create a new browsing context=] algorithm is invoked, after the
[=active document=] of the browsing context is set, run the following steps:

1. Let |context| be the newly created browsing context.

1. Let |related browsing contexts| be a set containing |context|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.contextCreated</code>" and |related browsing
   contexts|:

  1. [=Emit a context created event=] given |session| and |context|.

</div>

<div algorithm="remote end subscribe steps for browsingContext.contextCreated">

The [=remote end subscribe steps=], with [=subscribe priority=] 1, given
|session|, |contexts| and <var ignore>include global</var> are:

1. For each |context| in |contexts|:

  1. [=Recursively emit context created events=] given |session| and |context|.

</div>

#### The browsingContext.contextDestroyed Event #### {#event-browsingContext-contextDestroyed}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextDestroyedEvent = {
         method: "browsingContext.contextDestroyed",
         params: BrowsingContextInfo
       }
      </pre>
   </dd>
</dl>
The [=remote end event trigger=] is:

<div algorithm="remote end event trigger for browsingContext.contexDestroyed">

Define the following [=browsing context tree discarded=] steps:

1. Let |context| be the browsing context being discarded.

1. Let |params| be the result of [=get the browsing context info=], given
   |context|, 0, and true.

1. Let |body| be a [=map=] matching the
    <code>BrowsingContextDestroyedEvent</code> production, with the
    <code>params</code> field set to |params|.

1. Let |related browsing contexts| be a set containing the [=parent browsing
   context=] of |context|, if that is not null, or an empty set otherwise.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.contextDestroyed</code>" and |related browsing
   contexts|:

  1. [=Emit an event=] with |session| and |body|.

Issue: the way this hooks into HTML feels very fragile. See https://github.com/whatwg/html/issues/6194

Issue: It's unclear if we ought to only fire this event for browsing
contexts that have active documents; navigation can also cause contexts to
become inaccessible but not yet get discarded because bfcache.
</div>

#### The browsingContext.navigationStarted Event #### {#event-browsingContext-navigationStarted}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextNavigationStartedEvent = {
         method: "browsingContext.navigationStarted",
         params: NavigationInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi navigation
started</dfn> steps given |context| and |navigation status|:

1. Let |params| be the result of [=get the navigation info=] given |context|
   and |navigation status|.

 1. Let |body| be a [=map=] matching the
    <code>BrowsingContextNavigationStarted</code> production, with the
    <code>params</code> field set to |params|.

1. Let |navigation id| be |navigation status|'s id.

1. Let |related browsing contexts| be a set containing |context|.

1. [=Resume=] with "<code>navigation started</code>", |navigation id|, and
   |navigation status|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.navigationStarted</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

#### The browsingContext.fragmentNavigated Event #### {#event-browsingContext-fragmentNavigated}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextFragmentNavigatedEvent = {
         method: "browsingContext.fragmentNavigated",
         params: NavigationInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi fragment
navigated</dfn> steps given |context| and |navigation status|:

1. Let |params| be the result of [=get the navigation info=] given |context|
   and |navigation status|.

1. Let |body| be a [=map=] matching the
    <code>BrowsingContextFragmentNavigatedEvent</code> production, with the
    <code>params</code> field set to |params|.

1. Let |navigation id| be |navigation status|'s id.

1. Let |related browsing contexts| be a set containing |context|.

1. [=Resume=] with "<code>fragment navigated</code>", |navigation id|, and
   |navigation status|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.fragmentNavigated</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

#### The browsingContext.domContentLoaded Event #### {#event-browsingContext-domContentLoaded}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextDomContentLoadedEvent = {
         method: "browsingContext.domContentLoaded",
         params: NavigationInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi DOM content
loaded</dfn> steps given |context| and |navigation status|:

1. Let |params| be the result of [=get the navigation info=] given |context|
   and |navigation status|.

1. Let |body| be a [=map=] matching the
   <code>BrowsingContextDomContentLoadedEvent</code> production, with the
   <code>params</code> field set to |params|.

1. Let |related browsing contexts| be a set containing |context|.

1. Let |navigation id| be |navigation status|'s id.

1. [=Resume=] with "<code>domContentLoaded</code>", |navigation id|, and
   |navigation status|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.domContentLoaded</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

#### The browsingContext.load Event #### {#event-browsingContext-load}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextLoadEvent = {
         method: "browsingContext.load",
         params: NavigationInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi load
complete</dfn> steps given |context| and |navigation status|:

1. Let |params| be the result of [=get the navigation info=] given |context|
   and |navigation status|.

1. Let |body| be a [=map=] matching the <code>BrowsingContextLoadEvent</code>
   production, with the <code>params</code> field set to |params|.

1. Let |related browsing contexts| be a set containing |context|.

1. Let |navigation id| be |navigation status|'s id.

1. [=Resume=] with "<code>load</code>", |navigation id| and
   |navigation status|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.load</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

#### The browsingContext.downloadWillBegin Event #### {#event-browsingContext-downoadWillBegin}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextDownloadWillBeginEvent = {
         method: "browsingContext.downloadWillBegin",
         params: NavigationInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi download
started</dfn> steps given |context| and |navigation status|:

 1. Let |params| be the result of [=get the navigation info=] given |context|
    and |navigation status|.

 1. Let |body| be a [=map=] matching the
     <code>BrowsingContextDownloadWillBeginEvent</code> production, with the
     <code>params</code> field set to |params|.

 1. Let |navigation id| be |navigation status|'s id.

 1. Let |related browsing contexts| be a set containing |context|.

 1. [=Resume=] with "<code>download started</code>", |navigation id|, and |navigation status|.

 1. For each |session| in the [=set of sessions for which an event is enabled=]
    given "<code>browsingContext.downloadWillBegin</code>" and |related browsing contexts|:

   1. [=Emit an event=] with |session| and |body|.

</div>

#### The browsingContext.navigationAborted Event #### {#event-browsingContext-navigationAborted}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextNavigationAbortedEvent = {
         method: "browsingContext.navigationAborted",
         params: NavigationInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi navigation
aborted</dfn> steps given |context| and |navigation status|:

1. Let |params| be the result of [=get the navigation info=] given |context|
   and |navigation status|.

1. Let |body| be a [=map=] matching the
    <code>BrowsingContextNavigationAborted</code> production, with the
    <code>params</code> field set to |params|.

1. Let |navigation id| be |navigation status|'s id.

1. Let |related browsing contexts| be a set containing |context|.

1. [=Resume=] with "<code>navigation aborted</code>", |navigation id|, and |navigation status|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.navigationAborted</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>


#### The browsingContext.navigationFailed Event #### {#event-browsingContext-navigationFailed}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextNavigationFailedEvent = {
         method: "browsingContext.navigationFailed",
         params: NavigationInfo
       }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi navigation
failed</dfn> steps given |context| and |navigation status|:

1. Let |params| be the result of [=get the navigation info=] given |context|
   and |navigation status|.

1. Let |body| be a [=map=] matching the
    <code>BrowsingContextNavigationFailed</code> production, with the
    <code>params</code> field set to |params|.

1. Let |navigation id| be |navigation status|'s id.

1. Let |related browsing contexts| be a set containing |context|.

1. [=Resume=] with "<code>navigation failed</code>", |navigation id|, and |navigation status|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.navigationFailed</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

#### The browsingContext.userPromptClosed Event #### {#event-browsingContext-userPromptClosed}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextUserPromptClosedEvent = {
          method: "browsingContext.userPromptClosed",
          params: UserPromptClosedInfo
        }

        UserPromptClosedInfo = {
          context: BrowsingContext,
          accepted: bool,
          ? userText: text
        }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi user prompt
closed</dfn> steps given |window|, |accepted| and optional |user text|
(default: null).

1. Let |context| be |window|'s [=/browsing context=].

1. Let |context id| be the [=browsing context id=] for |context|.

1. Let |params| be a [=map=] matching the <code>UserPromptClosedInfo</code>
   production with the <code>context</code> field set to |context id|, the
   <code>accepted</code> field set to |accepted|, and the <code>userText</code> field set
   to |user text| if |user text| is not null or omitted otherwise.

1. Let |body| be a [=map=] matching the
   <code>BrowsingContextUserPromptClosedEvent</code> production, with the
   <code>params</code> field set to |params|.

1. Let |related browsing contexts| be a [=set=] containing |context|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.userPromptClosed</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

#### The browsingContext.userPromptOpened Event #### {#event-browsingContext-userPromptOpened}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        BrowsingContextUserPromptOpenedEvent = {
          method: "browsingContext.userPromptOpened",
          params: UserPromptOpenedInfo
        }

        UserPromptOpenedInfo = {
          context: BrowsingContext,
          type: "alert" / "confirm" / "prompt" / "beforeunload",
          message: text
        }
      </pre>
   </dd>
</dl>

<div algorithm>
The [=remote end event trigger=] is the <dfn export>WebDriver BiDi user prompt
opened</dfn> steps given |window|, |type| and |message|.

1. Let |context| be |window|'s [=/browsing context=].

1. Let |context id| be the [=browsing context id=] for |context|.

1. Let |params| be a [=map=] matching the <code>UserPromptOpenedInfo</code>
   production with the <code>context</code> field set to |context id|, the
   <code>type</code> field set to |type|, and the <code>message</code> field set
   to |message|.

1. Let |body| be a [=map=] matching the
   <code>BrowsingContextUserPromptOpenedEvent</code> production, with the
   <code>params</code> field set to |params|.

1. Let |related browsing contexts| be a [=set=] containing |context|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>browsingContext.userPromptOpened</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

## The script Module ## {#module-script}

The <dfn export for=modules>script</dfn> module contains commands and events
relating to script realms and execution.

### Definition ### {#module-script-definition}

[=Remote end definition=]

<pre class="cddl remote-cddl">
ScriptCommand = (
  ScriptCallFunctionCommand //
  ScriptDisownCommand //
  ScriptEvaluateCommand //
  ScriptGetRealmsCommand
)
</pre>

[=local end definition=]

<pre class="cddl local-cddl">
ScriptResult = (
  ScriptEvaluateResult //
  ScriptGetRealmsResult
)

ScriptEvent = (
  ScriptRealmCreatedEvent //
  ScriptRealmDestroyedEvent
)
</pre>


### Types ### {#module-script-types}

#### The script.ExceptionDetails type #### {#type-script-ExceptionDetails}

[=Remote end definition=] and [=local end definition=]

<pre class="cddl remote-cddl local-cddl">
ExceptionDetails = {
  columnNumber: js-uint,
  exception: RemoteValue,
  lineNumber: js-uint,
  stackTrace: StackTrace,
  text: text,
};
</pre>

The <code>ExceptionDetails</code> type represents a JavaScript exception.

<div algorithm>

To <dfn>get exception details</dfn> given a |realm|, a [=completion record=]
|record| and an |ownership type|:

1. Assert: |record|.\[[Type]] is <code>throw</code>.

1. Let |text| be an implementation-defined textual description of the error
   represented by |record|.

   TODO: Tighten up the requirements here; people will probably try to parse
   this data with regex or something equally bad.

1. Let |exception| be the result of [=serialize as a remote value=] given
   |record|.\[[Value]], <code>1</code> as max depth, |ownership type|,
   a new [=Map=] as serialization internal map and |realm|.

1. Let |stack trace| be the [=stack trace for an exception=] given |record|.

1. If |stack trace| has size of 1 or greater, let |line number| be value of the
   <code>lineNumber</code> field in |stack trace|[0], and let |column number| be
   the value of the <code>columnNumber</code> field |stack trace|[0]. Otherwise
   let |line number| and |column number| be 0.

1. Let |exception details| be a map matching the <code>ExceptionDetails</code>
   production, with the <code>text</code> field set to |text|, the
   <code>exception</code> field set to |exception|, the <code>lineNumber</code>
   field set to |line number|, the <code>columnNumber</code> field set to
   |column number|, and the <code>stackTrace</code> field set to |stack trace|.

1. Return |exception details|.

</div>

#### The script.Realm type #### {#type-script-Realm}

[=Remote end definition=] and [=local end definition=]

<pre class="cddl remote-cddl local-cddl">
Realm = text;
</pre>

Each [=realm=] has an associated <dfn export>realm id</dfn>, which is a string
uniquely identifying that realm. This is implicitly set when the realm is
created.

The [=realm id=] for a realm is opaque and must not be derivable from the handle
id of the corresponding global object in the [=handle object map=] or, where
relevant, from the [=browsing context id=] of any [=/browsing context=].

Note: this is to ensure that users do not rely on implementation-specific
relationships between different ids.

<div algorithm>
To <dfn>get a realm</dfn> given |realm id|:

1. If |realm id| is null, return [=success=] with data null.

1. If there is no [=realm=] with [=realm id|id=] |realm id| return
   [=error=] with [=error code=] [=no such frame=]

1. Let |realm| be the [=realm=] with [=realm id|id=] |realm id|.

1. Return [=success=] with data |realm|

Issue: This has the wrong error code
</div>

#### The script.RealmInfo type ####  {#type-script-RealmInfo}

[=Local end definition=]

<pre class="cddl local-cddl">
RealmInfo = {
  WindowRealmInfo //
  DedicatedWorkerRealmInfo //
  SharedWorkerRealmInfo //
  ServiceWorkerRealmInfo //
  WorkerRealmInfo //
  PaintWorkletRealmInfo //
  AudioWorkletRealmInfo //
  WorkletRealmInfo //
}

BaseRealmInfo = {
  realm: Realm,
  origin: text
}

WindowRealmInfo = {
  BaseRealmInfo,
  type: "window",
  context: BrowsingContext,
  ?sandbox: text
}

DedicatedWorkerRealmInfo = {
  BaseRealmInfo,
  type: "dedicated-worker"
}

SharedWorkerRealmInfo = {
  BaseRealmInfo,
  type: "shared-worker"
}

ServiceWorkerRealmInfo = {
  BaseRealmInfo,
  type: "service-worker"
}

WorkerRealmInfo = {
  BaseRealmInfo,
  type: "worker"
}

PaintWorkletRealmInfo = {
  BaseRealmInfo,
  type: "paint-worklet"
}

AudioWorkletRealmInfo = {
  BaseRealmInfo,
  type: "audio-worklet"
}

WorkletRealmInfo = {
  BaseRealmInfo,
  type: "worklet"
}
</pre>

Note: there's a 1:1 relationship between the <code>RealmInfo</code> variants and values of
      <a href="#type-script-RealmType"><code>RealmType</code></a>.

The <code>RealmInfo</code> type represents the properties of a realm.

<div algorithm>
To <dfn>get the realm info</dfn> given |environment settings|:

1. Let |realm| be |environment settings|' [=realm execution context=]'s Realm component.

1. Let |realm id| be the [=realm id=] for |realm|.

1. Let |origin| be the [=serialization of an origin=] given |environment settings|'s |origin|.

1. Let |global object| be the [=realm/global object=] specified by |environment settings|

1. Run the steps under the first matching condition:

  <dl>
    <dt>|global object| is a [=Window=] object
    <dd>
      1. Let |document| be |environment settings|' [=relevant global object=]'s
         <a>associated <code>Document</code></a>.
      1. Let |browsing context| be |document|'s [=/browsing context=].
      1. Let |context id| be the [=browsing context id=] for |browsing context|.
      1. Let |realm info| be a map matching the <code>WindowRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, the <code>origin</code>
         field set to |origin|, and the <code>context</code> field set to |context id|.

    <dt>|global object| is {{SandboxWindowProxy}} object
    <dd>
      TODO: Unclear if this is the right formulation for handling sandboxes.

      1. Let |document| be |global object|'s wrapped {{Window}}'s
         <a>associated <code>Document</code></a>.
      1. Let |browsing context| be |document|'s [=/browsing context=].
      1. Let |context id| be the [=browsing context id=] for |browsing context|.
      1. Let |sandbox name| be the result of [=get a sandbox name=] given
         |realm|.
      1. Assert: |sandbox name| is not null.
      1. Let |realm info| be a map matching the <code>WindowRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, the <code>origin</code>
         field set to |origin|, the <code>context</code> field set to |context id|,
         and the <code>sandbox</code> field set to |sandbox name|.


    <dt>|global object| is a {{DedicatedWorkerGlobalScope}} object
    <dd>
      1. Let |realm info| be a map matching the <code>DedicatedWorkerRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, and the <code>origin</code> field
         set to |origin|.

    <dt>|global object| is a {{SharedWorkerGlobalScope}} object
    <dd>
      1. Let |realm info| be a map matching the <code>SharedWorkerRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, and the <code>origin</code>
         field set to |origin|.

    <dt>|global object| is a {{ServiceWorkerGlobalScope}} object
    <dd>
      1. Let |realm info| be a map matching the <code>ServiceWorkerRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, and the <code>origin</code> field
         set to |origin|.

   <dt>|global object| is a {{WorkerGlobalScope}} object
   <dd>
      1. Let |realm info| be a map matching the <code>WorkerRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, and the <code>origin</code>
         field set to |origin|.

   <dt>|global object| is a {{PaintWorkletGlobalScope}} object
   <dd>
      1. Let |realm info| be a map matching the <code>PaintWorkletRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, and the <code>origin</code>
         field set to |origin|.

   <dt>|global object| is a {{AudioWorkletGlobalScope}} object
   <dd>
      1. Let |realm info| be a map matching the <code>AudioWorkletRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, and the <code>origin</code>
         field set to |origin|.

   <dt>|global object| is a {{WorkletGlobalScope}} object
   <dd>
      1. Let |realm info| be a map matching the <code>WorkletRealmInfo</code> production,
         with the <code>realm</code> field set to |realm id|, and the <code>origin</code>
         field set to |origin|.

   <dt>Otherwise:
   <dd>
      1. Let |realm info| be null.
  </dl>

1. Return |realm info|

Note: Future variations of this specification will retain the invariant that
         the last component of the type name after splitting on "<code>-</code>"
         will always be "<code>worker</code>" for globals implementing
         {{WorkerGlobalScope}}, and "<code>worklet</code>" for globals
         implementing {{WorkletGlobalScope}}.
</div>

#### The script.RealmType type ####  {#type-script-RealmType}

[=Local end definition=]

<pre class="cddl remote-cddl local-cddl">
RealmType = "window" / "dedicated-worker" / "shared-worker" / "service-worker" /
                       "worker" / "paint-worklet" / "audio-worklet" / "worklet"
</pre>

The <code>RealmType</code> type represents the different types of Realm.


#### The script.StackFrame type #### {#types-script-StackFrame}

<pre class="cddl remote-cddl local-cddl">
StackFrame = {
  columnNumber: js-uint,
  functionName: text,
  lineNumber: js-uint,
  url: text,
}
</pre>

A frame in a stack trace is represented by a <code>StackFrame</code>
object. This has a <code>url</code> property, which represents the URL of the
script, a <code>functionName</code> property which represents the name of the
executing function, and <code>lineNumber</code> and <code>columnNumber</code>
properties, which represent the line and column number of the executed code.

#### The script.StackTrace type #### {#types-script-StackTrace}

<pre class="cddl remote-cddl local-cddl">
StackTrace = {
  callFrames: [*StackFrame],
}
</pre>

The <code>StackTrace</code> type represents the javascript stack at a point in
script execution.

Note: The details of how to get a list of stack frames, and the properties of
that list are underspecified, and therefore the details here are implementation
defined.

It is assumed that an implementation is able to generate a <dfn>list of stack
frames</dfn>, which is a list with one entry for each item in the javascript
call stack, starting from the most recent. Each entry is a single <dfn>stack
frame</dfn> corresponding to execution of a statement or expression in a script
|script|, which contains the following fields:

<dl>
 <dt><dfn for=stackframe>script url</dfn>
 <dd>The url of the resource containing |script|
 <dt><dfn for=stackframe>function</dfn>
 <dd>The name of the function being executed
 <dt><dfn for=stackframe>line number</dfn>
 <dd>The zero-based line number of the executed code, relative to the top
 of the resource containing |script|.
 <dt><dfn for=stackframe>column number</dfn>
 <dd>The zero-based column number of the executed code, relative to the start of
 the line in the resource containing |script|.
</dl>

<div algorithm>

To <dfn>construct a stack trace</dfn>, with a list of stack frames |stack|:

1. Let |call frames| be a new list.

1. For each [=stack frame=] |frame| in |stack|,
   starting from the most recently executed frame, run the following steps:

   1. Let |url| be the result of running the [=URL serializer=], given
      the <a spec=url for=/>URL</a> of |frame|'s [=stackframe/script url=].

   1. Let |frame info| be a new map matching the <code>StackFrame</code>
      production, with the <code>url</code> field set to |url|, the
      <code>functionName</code> field set to |frame|'s [=stackframe/function=],
      the <code>lineNumber</code> field set to |frame|'s [=stackframe/line
      number=] and the <code>columnNumber</code> field set to |frame|'s
      [=stackframe/column number=].

1. Append |frame info| to |call frames|.

1. Let |stack trace| be a new map matching the <code>StackTrace</code>
   production, with the <code>callFrames</code> property set to |call frames|.

1. Return |stack trace|.

</div>

The <dfn>current stack trace</dfn> is the result of [=construct a stack trace=]
given a [=list of stack frames=] representing the callstack of the [=running
execution context=].

<div algorithm>

The <dfn>stack trace for an exception</dfn> with an exception, or a [=Completion
Record=] of type <code>throw</code>, |exception|, is given by:

1. If |exception| is a value that has been thrown as an exception, let |record|
   be the [=Completion Record=] created to throw |exception|. Otherwise let
   |record| be |exception|.

1. Let |stack| be the [=list of stack frames=] corresponding to execution at the
   point |record| was created.

1. Return [=construct a stack trace=] given |stack|.

</div>

#### The script.ScriptEvaluateResult type #### {#type-script-ScriptEvaluateResult}

[=Remote end definition=] and [=local end definition=]

<pre class="cddl remote-cddl local-cddl">
ScriptEvaluateResult = (
  ScriptEvaluateResultSuccess //
  ScriptEvaluateResultException
)

ScriptEvaluateResultSuccess = {
  result: RemoteValue,
  realm: Realm
}

ScriptEvaluateResultException = {
  exceptionDetails: ExceptionDetails
  realm: Realm
}
</pre>

The <code>ScriptEvaluateResult</code> type indicates the return value of a command
that executes script. The <code>ScriptEvaluateResultSuccess</code> variant is used in
cases where the script completes normally and the
<code>ScriptEvaluateResultException</code> variant is used in cases where the script
completes with a thrown exception.

#### The script.Source type #### {#type-script-Source}

[=Local end definition=]

<pre class="cddl local-cddl">
Source = (
  realm: Realm,
  ?context: BrowsingContext
);
</pre>

The <code>Source</code> type represents a <code>script.Realm</code> with
an optional <code>browsingContext.BrowsingContext</code> in which a
script related event occurred.

<div algorithm>
To <dfn>get the source</dfn> given |source realm|:

1. Let |realm| be the [=realm id=] for |source realm|.

1. Let |environment settings| be the [=environment settings object=] whose
   [=realm execution context=]'s Realm component is |source realm|.

1. If |environment settings| has a <a>associated <code>Document</code></a>:

  1. Let |document| be environment settings’ <a>associated <code>Document</code></a>.

  1. Let |browsing context| be |document|’s [=Document/browsing context=].

  1. Let |context id| be the [=browsing context id=] for |browsing context|.

  Otherwise let |browsing context| be null.

1. Let |source| be a [=map=] matching the
   <code>Source</code> production with the <code>realm</code>
   field set to |realm|, and the <code>context</code> field set
   to |context id| if |browsing context| is not null, or unset otherwise.

1. Return |source|.

</div>

#### The script.Target type #### {#type-script-Target}

[=Remote end definition=]

<pre class="cddl remote-cddl">
RealmTarget = {realm: Realm};

ContextTarget = {
  context: BrowsingContext,
  ?sandbox: text
}

ScriptTarget = (
  RealmTarget //
  ContextTarget
);
</pre>

The <code>ScriptTarget</code> type represents a value that is either a
<code>script.Realm</code> or a <code>browsingContext.BrowsingContext</code>. This
is useful in cases where a context identifier can stand in for the realm
associated with the context's active document.

<div algorithm>
To <dfn>get a realm from a target</dfn> given |target|:

1. If |target| matches the <code>ContextTarget</code> production:

  1. Let |context| be the result of [=trying=] to [=get a browsing context=]
     with |target|["<code>context</code>"].

  1. If |target| does not contain a field named "<code>sandbox</code>", or
     |target|["<code>sandbox</code>"] is an empty string:

    1. Let |document| be |context|'s [=active document=].

    1. Let |environment settings| be the [=environment settings object=] whose
       [=relevant global object=]'s <a>associated <code>Document</code></a> is
       |document|.

    1. Let |realm| be |environment settings|' [=realm execution context=]'s
       Realm component.

  1. Otherwise: let |realm| be result of [=trying=] to
     [=get or create a sandbox realm=] given |target|["<code>sandbox</code>"] and
     |context|.

1. Otherwise:

  1. Assert: |target| matches the <code>RealmTarget</code> production.

  1. Let |realm id| be the value of the <code>realm</code> field of |target|.

  1. Let |realm| be [=get a realm=] given |realm id|.

1. Return [=success=] with data |realm|

Issue: This has the wrong error code
</div>

#### The script.Ownership type #### {#type-script-Ownership}

<pre class="cddl remote-cddl local-cddl">
SerializationOwnershipModel = "root" / "none"
</pre>

The <code>SerializationOwnershipModel</code> specifies how the serialized value
ownership should be treated.


### Commands ### {#module-script-commands}

#### The script.disown Command ####  {#command-script-disown}

The <dfn export for=commands>script.disown</dfn> command disowns the given handles.
This does not guarantee the handled object will be garbage collected, as there can be
other handles or strong ECMAScript references.

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      ScriptDisownCommand = {
        method: "script.disown",
        params: ScriptDisownParameters
      }

      ScriptDisownParameters = {
        handles: [Handle]
        target: ScriptTarget;
      }
      </pre>
   </dd>
</dl>

<div algorithm="remote end steps for script.disown">
The [=remote end steps=] with |command parameters| are:

1. Let |realm| be the result of [=trying=] to [=get a realm from a target=]
   given the value of the <code>target</code> field of |command parameters|.

1. Let |handles| the value of the <code>handles</code> field of |command parameters|.

1. For each |handle id| of |handles|:

   1. Let |handle map| be |realm|'s [=handle object map=]

   1. If |handle map| contains |handle id|, remove |handle id| from the |handle map|.

</div>

#### The script.callFunction Command ####  {#command-script-callFunction}

The <dfn export for=commands>script.callFunction</dfn> command calls a provided
function with given arguments in a given realm.

<code>RealmInfo</code> can be either a realm or a browsing context.

Note: In case of an arrow function in <code>functionDeclaration</code>, the
<code>this</code> argument doesn't affect function's <code>this</code> binding.

<dl>
   <dt>Command Type</dt>
   <dd>
    <pre class="cddl remote-cddl">
      ScriptCallFunctionCommand = {
        method: "script.callFunction",
        params: ScriptCallFunctionParameters
      }

      ScriptCallFunctionParameters = {
        functionDeclaration: text;
        awaitPromise: bool;
        target: ScriptTarget;
        ?arguments: [ArgumentValue];
        ?this: ArgumentValue;
        ?resultOwnership: OwnershipModel;
      }

      ArgumentValue = (
        RemoteReference //
        LocalValue
      );

    </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
    <pre class="cddl">
      ScriptEvaluateResult
    </pre>
   </dd>
</dl>

Issue: TODO: Add timeout argument as described in the script.evaluate.

<div algorithm>

To <dfn>deserialize arguments</dfn> given |realm| and |serialized arguments list|:

1. Let |deserialized arguments list| be an empty list.

1. For each |serialized argument| of |serialized arguments list|:

  1. Let |deserialized argument| be the result of [=trying=] to [=deserialize local value=]
     given |realm| and |serialized argument|.

  1. Append |deserialized argument| to the |deserialized arguments list|.

1. Return [=success=] with data |deserialized arguments list|.

</div>

<div algorithm>
To <dfn>evaluate function body</dfn> given |function declaration|,
|environment settings|, |base URL|, and |options|:

Note: the |function declaration| is parenthesized and evaluated.

1. Let |parenthesized function declaration| be [=concatenate=]
   «"<code>(</code>", |function declaration|, "<code>)</code>"»

1. Let |function script| be the result of [=create a classic script=] with
   |parenthesized function declaration|, |environment settings|, |base URL|, and |options|.

1. [=Prepare to run script=] with |environment settings|.

1. Let |function body evaluation status| be [=ScriptEvaluation=](|function script|'s record).

1. [=Clean up after running script=] with |environment settings|.

1. Return |function body evaluation status|.

</div>


The [=remote end steps=] with |command parameters| are:

1. Let |realm| be the result of [=trying=] to [=get a realm from a target=]
   given the value of the <code>target</code> field of |command parameters|.

1. Let |realm id| be |realm|'s [=realm id=].

1. Let |environment settings| be the [=environment settings object=] whose
   [=realm execution context=]'s Realm component is |realm|.

1. Let |command arguments| be the value of the <code>arguments</code> field
   of |command parameters|.

1. Let |deserialized arguments| be an empty list.

1. If |command arguments| is not null, set |deserialized arguments| to the result of [=trying=] to
   [=deserialize arguments=] given |realm| and |command arguments|.

1. Let |this parameter| be the value of the <code>this</code> field
   of |command parameters|.

1. Let |this object| be null.

1. If |this parameter| is not null, set |this object| to the result of [=trying=] to
   [=deserialize local value=] given |realm| and |this parameter|.

1. Let |function declaration| be the value of the
   <code>functionDeclaration</code> field of |command parameters|.

1. Let |await promise| be the value of the <code>awaitPromise</code> field of
   |command parameters|.

1. Let |result ownership| be the value of the <code>resultOwnership</code> field of
   |command parameters|, if present, or <code>none</code> otherwise.

1. Let |function body evaluation status| be the result of [=evaluate function body=]
   (|function declaration|, |environment settings|, |base URL|, and |options|).

1. If |function body evaluation status|.\[[Type]] is <code>throw</code>:

   1. Let |exception details| be the result of [=get exception details=] given
      |realm|, |function body evaluation status| and |result ownership|.

   1. Return a new map matching the <code>ScriptEvaluateResultException</code>
      production, with the <code>exceptionDetails</code> field set to
      |exception details|.

1. Let |function object| be |function body evaluation status|.\[[Value]].

1. If [=IsCallable=](|function object|) is <code>false</code>:

   1. Return an [=error=] with [=error code=] [=invalid argument=]

1. [=Prepare to run script=] with |environment settings|.

1. Set |evaluation status| to
   [=Call=](|function object|, |this object|, |deserialized arguments|).

1. If |evaluation status|.\[[Type]] is <code>normal</code>, and |await promise| is
   <code>true</code>, and [=IsPromise=](|evaluation status|.\[[Value]]):

   1. Set |evaluation status| to
      <a spec=ECMASCRIPT>Await</a>(|evaluation status|.\[[Value]]).

1. [=Clean up after running script=] with |environment settings|.

1. If |evaluation status|.\[[Type]] is <code>throw</code>:

  1. Let |exception details| be the result of [=get exception details=] given
     |realm|, |evaluation status| and |result ownership|.

  1. Return a new map matching the <code>ScriptEvaluateResultException</code>
     production, with the <code>exceptionDetails</code> field set to
     |exception details|.

1. Assert: |evaluation status|.\[[Type]] is <code>normal</code>.

1. Let |result| be the result of [=serialize as a remote value=] given
   |evaluation status|.\[[Value]], <code>1</code> as |max depth|, |result
   ownership|, <code>new map</code> as |serialization internal map| and |realm|.

1. Return a new map matching the <code>ScriptEvaluateResultSuccess</code>
   production, with the <code>realm</code> field set to |realm id|,
   and the <code>result</code> field set to |result|.

#### The script.evaluate Command ####  {#command-script-evaluate}

The <dfn export for=commands>script.evaluate</dfn> command evaluates a provided
script in a given realm. For convenience a browsing context can be provided in
place of a realm, in which case the realm used is the realm of the browsing
context's active document.

The method returns the value of executing the provided script, unless it returns
a promise and <code>awaitPromise</code> is true, in which case the resolved value of
the promise is returned.

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      ScriptEvaluateCommand = {
        method: "script.evaluate",
        params: ScriptEvaluateParameters
      }

      ScriptEvaluateParameters = {
        expression: text;
        target: ScriptTarget;
        awaitPromise: bool;
        ?resultOwnership: OwnershipModel;
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
    <pre class="cddl">
    ScriptEvaluateResult
   </pre>
   </dd>
</dl>

TODO: Add timeout argument. It's not totally clear how this ought to work; in
Chrome it seems like the timeout doesn't apply to the promise resolve step, but
that likely isn't what clients want.

The [=remote end steps=] with |command parameters| are:

1. Let |realm| be the result of [=trying=] to [=get a realm from a target=]
   given the value of the <code>target</code> field of |command parameters|.

1. Let |realm id| be |realm|'s [=realm id=].

1. Let |environment settings| be the [=environment settings object=] whose
   [=realm execution context=]'s Realm component is |realm|.

1. Let |source| be the value of the <code>expression</code> field of |command
   parameters|.

1. Let |await promise| be the value of the <code>awaitPromise</code> field of
   |command parameters|.

1. Let |result ownership| be the value of the <code>resultOwnership</code> field of
   |command parameters|, if present, or <code>none</code> otherwise.

1. Let |options| be the [=default classic script fetch options=].

1. Let |base URL| be the [=API base URL=] of |environment settings|.

1. Let |script| be the result of [=create a classic script=] with |source|,
   |environment settings|, |base URL|, and |options|.

1. [=Prepare to run script=] with |environment settings|.

1. Set |evaluation status| to [=ScriptEvaluation=](|script|'s record).

1. If |evaluation status|.\[[Type]] is <code>normal</code>, |await promise| is
   true, and [=IsPromise=](|evaluation status|.\[[Value]]):

   1. Set |evaluation status| to <a spec=ECMASCRIPT>Await</a>(|evaluation status|.\[[Value]]).

1. [=Clean up after running script=] with |environment settings|.

1. If |evaluation status|.\[[Type]] is <code>throw</code>:

  1. Let |exception details| be the result of [=get exception details=] given
     |realm|, |evaluation status| and |result ownership|.

  1. Return a new map matching the <code>ScriptEvaluateResultException</code>
     production, with the <code>realm</code> field set to |realm id|, and the
     <code>exceptionDetails</code> field set to |exception details|.

1. Assert: |evaluation status|.\[[Type]] is <code>normal</code>.

1. Let |result| be the result of [=serialize as a remote value=] given
   |evaluation status|.\[[Value]], <code>1</code> as |max depth|, |result
   ownership|, <code>new map</code> as |serialization internal map| and |realm|.

1. Return a new map matching the <code>ScriptEvaluateResultSuccess</code>
   production, with the with the <code>realm</code> field set to |realm id|, and
   the <code>result</code> field set to |result|.

#### The script.getRealms Command ####  {#command-script-getRealms}

The <dfn export for=commands>script.getRealms</dfn> command returns a list of
all realms, optionally filtered to [=realms=] of a specific type, or to the
realm associated with the [=document=] currently loaded in a specified
[=/browsing context=].

<dl>
   <dt>Command Type</dt>
   <dd>
      <pre class="cddl remote-cddl">
      ScriptGetRealmsCommand = {
        method: "script.getRealms",
        params: ScriptGetRealmsParameters
      }

      ScriptGetRealmsParameters = {
        ?context: BrowsingContext,
        ?type: RealmType,
      }
      </pre>
   </dd>
   <dt>Return Type</dt>
   <dd>
    <pre class="cddl local-cddl">
      RealmInfoList = [* RealmInfo]

      ScriptGetRealmsResult = {
        realms: RealmInfoList
      }
    </pre>
   </dd>
</dl>

<div algorithm="remote end steps for script.getRealms">
The [=remote end steps=] with <var ignore>session</var> and |command parameters| are:

1. Let |environment settings| be a list of all the [=environment settings objects=]
   that have their [=execution ready flag=] set.

1. If |command parameters| contains <code>context</code>:

  1. Let |context| be the result of [=trying=] to [=get a browsing context=]
     with |command parameters|["<code>context</code>"].

  1. Let |document| be |context|'s [=active document=].

  1. Let |context environment settings| be a list.

  1. For each |settings| of |environment settings|:

    1. If any of the following conditions hold:

      * The <a>associated <code>Document</code></a> of |settings|'
        [=relevant global object=] is |document|

      * The [=realm/global object=] specified by |settings| is a
        {{WorkerGlobalScope}} with |document| in its [=owner set=]

      Append |settings| to |context environment settings|.

  1. Set |environment settings| to |context environment settings|.

1. Let |realms| be a list.

1. For each |settings| of |environment settings|:

  1. Let |realm info| be the result of [=get the realm info=] given |settings|

  1. If |command parameters| contains <code>type</code> and |realm
     info|["<code>type</code>"] is not equal to |command
     parameters|["<code>type</code>"] then [=continue=].

  1. If |realm info| is not null, append |realm info| to |realms|.

1. Let |body| be a map matching the <code>GetRealmsResult</code> production,
   with the <code>realms</code> field set to |realms|.

1. Return [=success=] with data |body|.


Issue: Extend this to also allow realm parents e.g. for nested workers? Or get all ancestor workers.

Issue: We might want to have a more sophisticated filter system than just a
       literal match.

</div>

### Events ### {#module-script-events}

#### The script.realmCreated Event #### {#event-script-realmCreated}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        ScriptRealmCreatedEvent = {
         method: "script.realmCreated",
         params: RealmInfo
       }
      </pre>
   </dd>
</dl>
The [=remote end event trigger=] is:

<div algorithm="remote end event trigger for script.realmCreated">

When any of the [=set up a window environment settings object=], [=set up a
worker environment settings object=] or [=set up a worklet environment settings
object=] algorithms are invoked, immediately prior to returning the settings
object:

1. Let |environment settings| be the newly created [=environment settings
   object=].

1. Let |realm info| be the result of [=get the realm info=] given
   |environment settings|.

1. If |realm info| is null, return.

1. Let |related browsing contexts| be the result of [=get related browsing
   contexts=] given |environment settings|.

1. Let |body| be a map matching the <code>RealmCreatedEvent</code>
   production, with the <code>params</code> field set to |realm info|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>script.realmCreated</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

</div>

<div algorithm="remote end subscribe steps for script.realmCreated">

The [=remote end subscribe steps=] with [=subscribe priority=] 2, given
|session|, |contexts| and |include global| are:

1. Let |environment settings| be a list of all the [=environment settings objects=]
   that have their [=execution ready flag=] set.

1. For each |settings| of |environment settings|:

  1. Let |related browsing contexts| be a new set.

  1. If the <a>associated <code>Document</code></a> of |settings|'
     [=relevant global object=] is a [=Document=]:

     1. Let |context| be |settings|'s [=relevant global object=]'s
        <a>associated <code>Document</code></a>'s
        [=Document/browsing context=]'s [=top-level browsing context=].

     1. If |context| is not in |contexts|, continue.

     1. Append |context| to |related browsing contexts|.

    Otherwise, if |include global| is false, continue.

  1. Let |realm info| be the result of [=get the realm info=] given |settings|

  1. Let |body| be a map matching the <code>RealmCreatedEvent</code>
     production, with the <code>params</code> field set to |realm info|.

  1. If [=event is enabled=] given |session|,
     "<code>script.realmCreated</code>" and |related browsing contexts|:

    1. [=Emit an event=] with |session| and |body|.

Issue: Should the order here be better defined?

</div>

#### The script.realmDestroyed Event #### {#event-script-realmDestroyed}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
       RealmDestroyedParameters = {
         realm: Realm
       }

       ScriptRealmDestroyedEvent = {
         method: "script.realmDestoyed",
         params: RealmDestroyedParameters
       }
      </pre>
   </dd>
</dl>
The [=remote end event trigger=] is:

<div algorithm="remote end event trigger for script.realmDestroyed">
Define the following [=unloading document cleanup steps=] with |document|:

1. Let |related browsing contexts| be an empty set.

1. Append |document|'s [=Document/browsing context=] to |related browsing
   contexts|.

1. For each |worklet global scope| in |document|'s [=worklet global scopes=]:

  1. Let |realm| be |worklet global scope|'s [=relevant Realm=].

  1. Let |realm id| be the [=realm id=] for |realm|.

  1. Let |params| be a map matching the <code>RealmDestroyedParameters</code>
     production, with the <code>realm</code> field set of |realm id|.

  1. Let |body| be a map matching the <code>RealmDestroyedEvent</code>
     production, with the <code>params</code> field set to |params|.

  1. For each |session| in the [=set of sessions for which an event is enabled=]
     given "<code>script.realmDestroyed</code>" and |related browsing contexts|:

    1. [=Emit an event=] with |session| and |body|.

1. Let |environment settings| be the [=environment settings object=] whose
   [=relevant global object=]'s <a>associated <code>Document</code></a> is
   |document|.


1. Let |realm| be |environment settings|' [=realm execution context=]'s Realm component.

1. Let |realm id| be the [=realm id=] for |realm|.

1. Let |params| be a map matching the <code>RealmDestroyedParameters</code>
   production, with the <code>realm</code> field set to |realm id|.

1. Let |body| be a map matching the <code>RealmDestroyedEvent</code>
   production, with the <code>params</code> field set to |params|.

1. For each |session| in the [=set of sessions for which an event is enabled=]
   given "<code>script.realmDestroyed</code>" and |related browsing contexts|:

  1. [=Emit an event=] with |session| and |body|.

Whenever a [=worker event loop=] |event loop| is destroyed, either because the
worker comes to the end of its lifecycle, or prematurely via the [=terminate a
worker=] algorithm:

1. Let |environment settings| be the [=environment settings object=] for which
   |event loop| is the [=responsible event loop=].

1. Let |related browsing contexts| be the result of [=get related browsing
   contexts=] given |environment settings|.

1. Let |realm| be |environment settings|'s [=environment settings object's Realm=].

1. Let |realm id| be the [=realm id=] for |realm|.

1. Let |params| be a map matching the <code>RealmDestroyedParameters</code>
   production, with the <code>realm</code> field set of |realm id|.

1. Let |body| be a map matching the <code>RealmDestroyedEvent</code>
   production, with the <code>params</code> field set to |params|.

</div>

## The log Module ## {#module-log}

The <dfn export for=modules>log</dfn> module contains functionality and events
related to logging.

A [=BiDi Session=] has a <dfn>log event buffer</dfn> which is a [=map=] from
[=browsing context id=] to a list of log events for that context that have not
been emitted. User agents may impose a maximum size on this buffer, subject to
the condition that if events A and B happen in the same context with A occuring
before B, and both are added to the buffer, the entry for B must not be removed
before the entry for A.

<div algorithm>

To <dfn>buffer a log event</dfn> given |session|, |contexts| and |event|:

1. Let |buffer| be |session|'s [=log event buffer=].

1. Let |context ids| be a new list.

1. For each |context| of |contexts|:

  1. Append the [=browsing context id=] for |context| to |context ids|.

1. For each |context id| in |context ids|:

  1. Let |other contexts| be an empty list

  1. For each |other id| in |context ids|:

   1. If |other id| is not equal to |context id|, append |other id| to |other
      contexts|.

  1. If |buffer| does not contain |context id|, let |buffer|[|context id|] be a
     new list.

  1. Append (|event|, |other contexts|) to |buffer|[|context id|].

Note: we store the other contexts here so that each event is only emitted
once. In practice this is only relevant for workers that can be associated with
multiple browsing contexts.

Issue: Do we want to key this on browsing context or top-level browsing context?
The difference is in what happens if an event occurs in a frame and that frame
is then navigated before the local end subscribes to log events for the top
level context.

</div>

### Definition ### {#module-log-definition}

[=Local end definition=]

<pre class="cddl local-cddl">
LogEvent = (
  LogEntryAddedEvent
)
</pre>

### Types ### {#module-log-types}

#### log.LogEntry #### {#types-log-logentry}

[=Local end definition=]

<pre class="cddl local-cddl">
LogLevel = "debug" / "info" / "warn" / "error"

LogEntry = (
  GenericLogEntry //
  ConsoleLogEntry //
  JavascriptLogEntry
)

BaseLogEntry = {
  level: LogLevel,
  source: Source,
  text: text / null,
  timestamp: js-uint,
  ?stackTrace: StackTrace,
}

GenericLogEntry = {
  BaseLogEntry,
  type: text,
}

ConsoleLogEntry = {
  BaseLogEntry,
  type: "console",
  method: text,
  args: [*RemoteValue],
}

JavascriptLogEntry = {
  BaseLogEntry,
  type: "javascript",
}
</pre>

Each log event is represented by a <code>LogEntry</code> object. This has a
<code>type</code> property which represents the type of log entry added, a
<code>level</code> property representing severity, a <code>source</code>
property representing the origin of the log entry, a <code>text</code> property
with the log message string itself, and a <code>timestamp</code> property
corresponding to the time the log entry was generated. Specific variants of the
<code>LogEntry</code> are used to represent logs from different sources, and
provide additional fields specific to the entry type.

### Events ### {#module-log-events}

#### The log.entryAdded Event #### {#event-log-entryAdded}

<dl>
   <dt>Event Type</dt>
   <dd>
      <pre class="cddl local-cddl">
        LogEntryAddedEvent = {
         method: "log.entryAdded",
         params: LogEntry,
       }
      </pre>
   </dd>
</dl>

The [=remote end event trigger=] is:

<div algorithm="remote end event trigger for log.entryAdded">

Define the following [=console steps=] with |method|, |args|, and <var
ignore>options</var>:

1. If |method| is "<code>error</code>" or "<code>assert</code>", let |level| be
   "<code>error</code>". If |method| is "<code>debug</code>" or "<code>trace</code>"
   let |level| be "<code>debug</code>". If |method| is "<code>warn</code>", let
   |level| be "<code>warn</code>". Otherwise let |level| be "<code>info</code>".

1. Let |timestamp| be a [=time value=] representing the current date and time in UTC.

1. Let |text| be an empty string.

1. If [=Type=](|args|[0]) is String, and |args|[0] contains a
   [=formatting specifier=], let |formatted args| be [=Formatter=](|args|). Otherwise
   let |formatted args| be |args|.

   Note: The formatter operation is underdefined in the console specification,
   formatting can be inconsistent between different implementations.

1. For each |arg| in |formatted args|:

  1. If |arg| is not the first entry in |args|, append a U+0020 SPACE to |text|.

  1. If |arg| is a [=primitive ECMAScript value=], append [=ToString=](|arg|) to
     |text|. Otherwise append an implementation-defined string to |text|.

1. Let |realm| be the [=realm id=] of the [=current Realm Record=].

1. Let |serialized args| be a new list.

1. For each |arg| of |args|:
   1. Let |serialized arg| be the result of [=serialize as a remote value=] given
      |arg| as value, <code>1</code> as max depth, <code>none</code> as
      ownership type, a new [=Map=] as serialization internal map, and
      |realm|.

   1. Add |serialized arg| to |serialized args|.

1. Let |source| be the result of [=get the source=] given [=current Realm Record=].

1. If |method| is "<code>assert</code>", "<code>error</code>",
   "<code>trace</code>", or "<code>warn</code>", let |stack| be the [=current
   stack trace=]. Otherwise let |stack| be null.

1. Let |entry| be a map matching the <code>ConsoleLogEntry</code> production,
   with the the <code>level</code> field set to |level|, the <code>text</code>
   field set to |text|, the <code>timestamp</code> field set to |timestamp|, the
   <code>stackTrace</code> field set to |stack| if |stack| is not null, or
   omitted otherwise, the |method| field set to |method|, the <code>source</code>
   field set to |source| and the <code>args</code> field set to |serialized
   args|.

1. Let |body| be a map matching the <code>LogEntryAddedEvent</code> production, with
   the <code>params</code> field set to |entry|.

1. Let |settings| be the [=current settings object=]

1. Let |related browsing contexts| be the result of [=get related browsing
   contexts=] given |settings|.

1. For each |session| in [=active BiDi sessions=]:

  1. If [=event is enabled=] with |session|, "<code>log.entryAdded</code>" and
     |related browsing contexts|, [=emit an event=] with |session| and |body|.

     Otherwise, [=buffer a log event=] with |session|, |related browsing
     contexts|, and |body|.

Define the following [=error reporting steps=] with arguments |script|, <var
ignore>line number</var>, <var ignore>column number</var>, |message| and
|handled|:

1. If |handled| is true return.

1. Let |settings| be |script|'s [=script/settings object=].

1. Let |stack| be the [=stack trace for an exception=] with the exception
   corresponding to the error being reported.

1. Let |source| be the result of [=get the source=] given [=current Realm Record=].

1. Let |entry| be a map matching the <code>JavascriptLogEntry</code> production,
   with <code>level</code> set to "<code>error</code>", <code>text</code> set to
   |message|, <code>source</code> set to |source|, and the <code>timestamp</code>
   field set to |timestamp|.

1. Let |related browsing contexts| be the result of [=get related browsing
   contexts=] given |settings|.

1. For each |session| in [=active BiDi sessions=]:

  1. If [=event is enabled=] with |session|, "<code>log.entryAdded</code>" and
     |related browsing contexts|, [=emit an event=] with |session| and |body|.

     Otherwise, [=buffer a log event=] with |session|, |related browsing
     contexts|, and |body|.

Issue: Lots more things require logging. CDP has LogEntryAdded types xml,
javascript, network, storage, appcache, rendering, security, deprecation,
worker, violation, intervention, recommendation, other. These are in addition to
the js exception and console API types that are represented by different methods.

Issue: Allow implementation-defined log types

</div>

<div algorithm="remote end subscribe steps for log.entryAdded">

The [=remote end subscribe steps=], with [=subscribe priority=] 10, given
|session|, |contexts| and |include global| are:

1. For each |context id| → |events| in |session|'s [=log event buffer=]:

  1. Let |maybe context| be the result of [=getting a browsing context=] given
     |context id|.

  1. If |maybe context| is an [=error=], remove |context id| from [=log event
     buffer=] and continue.

  1. Let |context| be |maybe context|'s data

  1. Let |top level context| be |context|'s [=top-level browsing context=].

  1. If |include global| is true and |top level context| is not in |contexts|,
     or if |include global| is false and |top level context| is in |contexts|:

    1. For each (|event|, |other contexts|) in |events|:

      1. [=Emit an event=] with |session| and |event|.

      1. For each |other context id| in |other contexts|:

        1. If [=log event buffer=] contains |other context id|, remove |event|
           from [=log event buffer=][|other context id|].

</div>

# Patches to Other Specifications # {#patches}

This specification requires some changes to external specifications to provide the necessary
integration points. It is assumed that these patches will be committed to the other specifications
as part of the standards process.

## HTML ##  {#patches-html}

The [=a browsing context is discarded=] algorithm is modified to read as follows:

<div algorithm>
To discard a browsing context |browsingContext|, run these steps:

1. If this is not a recursive invocation of this algorithm, call any <dfn export>browsing context
   tree discarded</dfn> steps defined in other applicable specifications with |browsingContext|.

1. Discard all {{Document}} objects for all the entries in |browsingContext|'s [=session
   history=].

1. If |browsingContext| is a [=top-level browsing context=], then [=remove a browsing context=]
   |browsingContext|.

</div>

Issue: The actual patch might be better to split the algorithm into an outer algorithm that is
called by external callers and an inner algorithm that's used for recursive calls. That's quite hard
to express as a patch to the specification since it requires changing multiple parts.


The [=report an error=] algorithm is modified with an additional step at the
end:

<div algorithm>
1. Call any <dfn>error reporting steps</dfn> defined in external specifications
   with <var ignore>script</var>, <var ignore>line</var>, <var
   ignore>col</var>, <var ignore>message</var>, and true if the error is
   [=handled=], or false otherwise.

</div>
## Console ##  {#patches-console}

Other specifications can define <dfn>console steps</dfn>. When any method of the
{{console}} interface is called, with method name
|method| and argument |args|:

1. If that method does not call the [=Printer=] operation, call any [=console
   steps=] defined in external specification with arguments |method|, |args|,
   and undefined.

   Otherwise, at the point when the [=Printer=] operation is called with
   arguments |name|, |printerArgs| and |options| (which is undefined if the
   argument is not provided), call any [=console steps=] defined in
   external specification with arguments |name|, |printerArgs|, and |options|.
